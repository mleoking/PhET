<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
   <title>Chapter&nbsp;2.&nbsp;NIO extensions</title><link rel="stylesheet" href="css/hc-tutorial.css" type="text/css"><meta name="generator" content="DocBook XSL-NS Stylesheets V1.75.2"><link rel="home" href="index.html" title="HttpCore Tutorial"><link rel="up" href="index.html" title="HttpCore Tutorial"><link rel="prev" href="fundamentals.html" title="Chapter&nbsp;1.&nbsp;Fundamentals"><link rel="next" href="advanced.html" title="Chapter&nbsp;3.&nbsp;Advanced topics"></head><body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF"><div xmlns:fo="http://www.w3.org/1999/XSL/Format" class="banner"><a class="bannerLeft" href="http://www.apache.org/" title="Apache Software Foundation"><img style="border:none;" src="images/asf_logo_wide.gif"></a><a class="bannerRight" href="http://hc.apache.org/httpcomponents-core/" title="Apache HttpComponents Core"><img style="border:none;" src="images/hc_logo.png"></a><div class="clear"></div></div><div class="navheader"><table width="100%" summary="Navigation header"><tr><th colspan="3" align="center">Chapter&nbsp;2.&nbsp;NIO extensions</th></tr><tr><td width="20%" align="left"><a accesskey="p" href="fundamentals.html">Prev</a>&nbsp;</td><th width="60%" align="center">&nbsp;</th><td width="20%" align="right">&nbsp;<a accesskey="n" href="advanced.html">Next</a></td></tr></table><hr></div><div class="chapter" title="Chapter&nbsp;2.&nbsp;NIO extensions"><div class="titlepage"><div><div><h2 class="title"><a name="nio"></a>Chapter&nbsp;2.&nbsp;NIO extensions</h2></div></div></div>
    
    <div class="section" title="2.1.&nbsp;Benefits and shortcomings of the non-blocking I/O model"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e490"></a>2.1.&nbsp;Benefits and shortcomings of the non-blocking I/O model</h2></div></div></div>
        
        <p>
        Contrary to the popular belief, the performance of NIO in terms of raw data throughput is 
        significantly lower than that of blocking I/O. NIO does not necessarily fit all use cases 
        and should be used only where appropriate: 
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                <p>
                handling of thousands of connections, a significant number of which can be idle.
                </p>
            </li><li class="listitem">
                <p>
                handling high latency connections.
                </p>
            </li><li class="listitem">
                <p>
                request / response handling needs to be decoupled.
                </p>
            </li></ul></div>
    </div>
    <div class="section" title="2.2.&nbsp;Differences from other NIO frameworks"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e500"></a>2.2.&nbsp;Differences from other NIO frameworks</h2></div></div></div>
        
        <p>
        Solves similar problems as other frameworks, but has certain distinct features: 
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                <p>
                minimalistic, optimized for data volume intensive protocols such as HTTP.
                </p>
            </li><li class="listitem">
                <p>
                efficient memory management: data consumer can read only as much input data as it 
                can process without having to allocate more memory.
                </p>
            </li><li class="listitem">
                <p>
                direct access to the NIO channels where possible.
                </p>
            </li></ul></div>
    </div>
    <div class="section" title="2.3.&nbsp;I/O reactor"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e510"></a>2.3.&nbsp;I/O reactor</h2></div></div></div>
        
        <p>
        HttpCore NIO is based on the Reactor pattern as described by Doug Lea. The purpose of I/O 
        reactors is to react to I/O events and to dispatch event notifications to individual I/O 
        sessions. The main idea of I/O reactor pattern is to break away from the one thread per 
        connection model imposed by the classic blocking I/O model. The <code class="interfacename">IOReactor
        </code> interface represents an abstract object implementing the Reactor pattern. 
        Internally, <code class="interfacename">IOReactor</code> implementations encapsulate 
        functionality of the NIO <code class="classname">java.nio.channels.Selector</code>.
        </p>
        <p>
        I/O reactors usually employ a small number of dispatch threads (often as few as one) to 
        dispatch I/O event notifications to a much greater number (often as many as several 
        thousands) of I/O sessions or connections. It is generally recommended to have one dispatch 
        thread per CPU core.
        </p>
        <pre class="programlisting">
HttpParams params = new BasicHttpParams();
int workerCount = 2;
IOReactor ioreactor = new DefaultConnectingIOReactor(workerCount, 
    params);
</pre>
        <div class="section" title="2.3.1.&nbsp;I/O dispatchers"><div class="titlepage"><div><div><h3 class="title"><a name="d4e518"></a>2.3.1.&nbsp;I/O dispatchers</h3></div></div></div>
            
            <p>
            <code class="interfacename">IOReactor</code> implementations make use of the 
            <code class="interfacename">IOEventDispatch</code> interface to notify clients of events 
            pending for a particular session. All methods of the <code class="interfacename">IOEventDispatch
            </code> are executed on a dispatch thread of the I/O reactor. Therefore, it is 
            important that processing that takes place in the event methods will not block the 
            dispatch thread for too long, as the I/O reactor will be unable to react to other 
            events. 
            </p>
            <pre class="programlisting">
HttpParams params = new BasicHttpParams();
IOReactor ioreactor = new DefaultConnectingIOReactor(2, params);
     
IOEventDispatch eventDispatch = new MyIOEventDispatch();
ioreactor.execute(eventDispatch);
</pre>
            <p>
            Generic I/O events as defined by the <code class="interfacename">IOEventDispatch</code> 
            interface:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p title="connected:">
                    <b><code class="methodname">connected</code>:&nbsp;</b>
                    
                    Triggered when a new session has been created.
                    
                    </p>
                </li><li class="listitem">
                    <p title="inputReady:">
                    <b><code class="methodname">inputReady</code>:&nbsp;</b>
                    
                    Triggered when the session has pending input.
                    
                    </p>
                </li><li class="listitem">
                    <p title="outputReady:">
                    <b><code class="methodname">outputReady</code>:&nbsp;</b>
                    
                    Triggered when the session is ready for output.
                    
                    </p>
                </li><li class="listitem">
                    <p title="timeout:">
                    <b><code class="methodname">timeout</code>:&nbsp;</b>
                    
                    Triggered when the session has timed out.
                    
                    </p>
                </li><li class="listitem">
                    <p title="disconnected:">
                    <b><code class="methodname">disconnected</code>:&nbsp;</b>
                    
                    Triggered when the session has been terminated.
                    
                    </p>
                </li></ul></div>
        </div>
        <div class="section" title="2.3.2.&nbsp;I/O reactor shutdown"><div class="titlepage"><div><div><h3 class="title"><a name="d4e553"></a>2.3.2.&nbsp;I/O reactor shutdown</h3></div></div></div>
            
            <p>
            The shutdown of I/O reactors is a complex process and may usually take a while to 
            complete. I/O reactors will attempt to gracefully terminate all active I/O sessions and 
            dispatch threads approximately within the specified grace period. If any of the I/O 
            sessions fails to terminate correctly, the I/O reactor will forcibly shut down 
            remaining sessions.    
            </p>
            <pre class="programlisting">
long gracePeriod = 3000L; // milliseconds
ioreactor.shutdown(gracePeriod);
</pre>
            <p>
            The <code class="methodname">IOReactor#shutdown(long)</code> method is safe to call from any 
            thread.
            </p>
        </div>
        <div class="section" title="2.3.3.&nbsp;I/O sessions"><div class="titlepage"><div><div><h3 class="title"><a name="d4e559"></a>2.3.3.&nbsp;I/O sessions</h3></div></div></div>
            
            <p>
            The <code class="interfacename">IOSession</code> interface represents a sequence of 
            logically related data exchanges between two end points. <code class="interfacename">IOSession
            </code> encapsulates functionality of NIO <code class="classname">
            java.nio.channels.SelectionKey</code> and <code class="classname">
            java.nio.channels.SocketChannel</code>. The channel associated with the 
            <code class="interfacename">IOSession</code> can be used to read data from and write data 
            to the session.
            </p>
            <pre class="programlisting">
IOSession iosession;
ReadableByteChannel ch = (ReadableByteChannel) iosession.channel();
ByteBuffer dst = ByteBuffer.allocate(2048); 
ch.read(dst);
</pre>
        </div>
        <div class="section" title="2.3.4.&nbsp;I/O session state management"><div class="titlepage"><div><div><h3 class="title"><a name="d4e568"></a>2.3.4.&nbsp;I/O session state management</h3></div></div></div>
            
            <p>
            I/O sessions are not bound to an execution thread, therefore one cannot use the context 
            of the thread to store a session's state. All details about a particular session must 
            be stored within the session itself. 
            </p>
            <pre class="programlisting">
IOSession iosession;
Object someState;
iosession.setAttribute("state", someState);
Object currentState = iosession.getAttribute("state");
</pre>
            <p>
            Please note that if several sessions make use of shared objects, access to those 
            objects must be made thread-safe. 
            </p>
        </div>
        <div class="section" title="2.3.5.&nbsp;I/O session event mask"><div class="titlepage"><div><div><h3 class="title"><a name="d4e573"></a>2.3.5.&nbsp;I/O session event mask</h3></div></div></div>
            
            <p>
            One can declare an interest in a particular type of I/O events for a particular I/O 
            session by setting its event mask. 
            </p>
            <pre class="programlisting">
IOSession iosession;
iosession.setEventMask(SelectionKey.OP_READ | SelectionKey.OP_WRITE);
</pre>
            <p>
            One can also toggle <code class="literal">OP_READ</code> and <code class="literal">OP_WRITE</code> flags 
            individually.
            </p>
            <pre class="programlisting">
iosession.setEvent(SelectionKey.OP_READ);
iosession.clearEvent(SelectionKey.OP_READ);
</pre>
            <p>
            Event notifications will not take place if the corresponding interest flag is not set.
            </p>
        </div>
        <div class="section" title="2.3.6.&nbsp;I/O session buffers"><div class="titlepage"><div><div><h3 class="title"><a name="d4e582"></a>2.3.6.&nbsp;I/O session buffers</h3></div></div></div>
            
            <p>
            Quite often I/O sessions need to maintain internal I/O buffers in order to transform 
            input / output data prior to returning it to the consumer or writing it to the 
            underlying channel. Memory management in HttpCore NIO is based on the fundamental 
            principle that the data consumer can read only as much input data as it can process 
            without having to allocate more memory. That means, quite often some input data may 
            remain unread in one of the internal or external session buffers. The I/O reactor can 
            query the status of these session buffers, and make sure the consumer gets notified 
            correctly as more data gets stored in one of the session buffers, thus allowing the 
            consumer to read the remaining data once it is able to process it. I/O sessions can be 
            made aware of the status of external session buffers using the <code class="interfacename">
            SessionBufferStatus</code> interface. 
            </p>
            <pre class="programlisting">
IOSession iosession;
SessionBufferStatus myBufferStatus = new MySessionBufferStatus(); 
iosession.setBufferStatus(myBufferStatus);
iosession.hasBufferedInput();
iosession.hasBufferedOutput();
</pre>
        </div>
        <div class="section" title="2.3.7.&nbsp;I/O session shutdown"><div class="titlepage"><div><div><h3 class="title"><a name="d4e587"></a>2.3.7.&nbsp;I/O session shutdown</h3></div></div></div>
            
            <p>
            One can close an I/O session gracefully by calling <code class="methodname">IOSession#close() 
            </code> allowing the session to be closed in an orderly manner or by calling 
            <code class="methodname">IOSession#shutdown()</code> to forcibly close the underlying channel. 
            The distinction between two methods is of primary importance for those types of I/O 
            sessions that involve some sort of a session termination handshake such as SSL/TLS 
            connections.
            </p>
        </div>
        <div class="section" title="2.3.8.&nbsp;Listening I/O reactors"><div class="titlepage"><div><div><h3 class="title"><a name="d4e592"></a>2.3.8.&nbsp;Listening I/O reactors</h3></div></div></div>
            
            <p>
            <code class="interfacename">ListeningIOReactor</code> represents an I/O reactor capable of 
            listening for incoming connections on one or several ports.
            </p>
            <pre class="programlisting">
ListeningIOReactor ioreactor;
        
ListenerEndpoint ep1 = ioreactor.listen(new InetSocketAddress(8081));
ListenerEndpoint ep2 = ioreactor.listen(new InetSocketAddress(8082));
ListenerEndpoint ep3 = ioreactor.listen(new InetSocketAddress(8083));

// Wait until all endpoints are up
ep1.waitFor();
ep2.waitFor();
ep3.waitFor();
</pre>
            <p>
            Once an endpoint is fully initialized it starts accepting incoming connections and 
            propagates I/O activity notifications to the <code class="interfacename">IOEventDispatch
            </code> instance.
            </p>
            <p>
            One can obtain a set of registered endpoints at runtime, query the status of an 
            endpoint at runtime, and close it if desired.
            </p>
            <pre class="programlisting">
ListeningIOReactor ioreactor;
        
Set&lt;ListenerEndpoint&gt; eps = ioreactor.getEndpoints();
for (ListenerEndpoint ep: eps) {
    // Still active?
    System.out.println(ep.getAddress());
    if (ep.isClosed()) {
        // If not, has it terminated due to an exception?
        if (ep.getException() != null) {
            ep.getException().printStackTrace();
        }
    } else {
        ep.close();
    }
}
</pre>
        </div>
        <div class="section" title="2.3.9.&nbsp;Connecting I/O reactors"><div class="titlepage"><div><div><h3 class="title"><a name="d4e601"></a>2.3.9.&nbsp;Connecting I/O reactors</h3></div></div></div>
            
            <p>
            <code class="interfacename">ConnectingIOReactor</code> represents an I/O reactor capable of 
            establishing connections with remote hosts.
            </p>
            <pre class="programlisting">
ConnectingIOReactor ioreactor;

SessionRequest sessionRequest = ioreactor.connect(
        new InetSocketAddress("www.google.com", 80), 
        null, null, null);
</pre>
            <p>
            Opening a connection to a remote host usually tends to be a time consuming process and 
            may take a while to complete. One can monitor and control the process of session 
            initialization by means of the <code class="interfacename">SessionRequest</code>interface. 
            </p>
            <pre class="programlisting">
// Make sure the request times out if connection 
// has not been established after 1 sec
sessionRequest.setConnectTimeout(1000);
// Wait for the request to complete
sessionRequest.waitFor();
// Has request terminated due to an exception?
if (sessionRequest.getException() != null) {
    sessionRequest.getException().printStackTrace();
}
// Get hold of the new I/O session
IOSession iosession = sessionRequest.getSession();
</pre>
            <p>
            <code class="interfacename">SessionRequest</code> implementations are expected to be 
            thread-safe. Session request can be aborted at any time by calling <code class="methodname">
            IOSession#cancel()</code> from another thread of execution.
            </p>
            <pre class="programlisting">
if (!sessionRequest.isCompleted()) {
    sessionRequest.cancel();
}
</pre>
            <p>
            One can pass several optional parameters to the <code class="methodname">
            ConnectingIOReactor#connect()</code> method to exert a greater control over the 
            process of session initialization. 
            </p>
            <p>
            A non-null local socket address parameter can be used to bind the socket to a specific 
            local address.
            </p>
            <pre class="programlisting">
ConnectingIOReactor ioreactor;

SessionRequest sessionRequest = ioreactor.connect(
        new InetSocketAddress("www.google.com", 80), 
        new InetSocketAddress("192.168.0.10", 1234), 
        null, null);
</pre>
            <p>
            One can provide an attachment object, which will be added to the new session's context 
            upon initialization. This object can be used to pass an initial processing state to 
            the protocol handler.
            </p>
            <pre class="programlisting">
SessionRequest sessionRequest = ioreactor.connect(
        new InetSocketAddress("www.google.com", 80), 
        null, new HttpHost("www.google.ru"), null);
        
IOSession iosession = sessionRequest.getSession();
HttpHost virtualHost = (HttpHost) iosession.getAttribute(
    IOSession.ATTACHMENT_KEY);
</pre>
            <p>
            It is often desirable to be able to react to the completion of a session request 
            asynchronously without having to wait for it, blocking the current thread of execution. 
            One can optionally provide an implementation <code class="interfacename">SessionRequestCallback
            </code> interface to get notified of events related to session requests, such 
            as request completion, cancellation, failure or timeout.
            </p>
            <pre class="programlisting">
ConnectingIOReactor ioreactor;

SessionRequest sessionRequest = ioreactor.connect(
        new InetSocketAddress("www.google.com", 80), null, null,
        new SessionRequestCallback() {

            public void cancelled(SessionRequest request) {
            }

            public void completed(SessionRequest request) {
                System.out.println("new connection to " + 
                    request.getRemoteAddress());
            }

            public void failed(SessionRequest request) {
                if (request.getException() != null) {
                    request.getException().printStackTrace();
                }
            }

            public void timeout(SessionRequest request) {
            }
            
        });
</pre>
        </div>
        <div class="section" title="2.3.10.&nbsp;Queuing of I/O interest set operations"><div class="titlepage"><div><div><h3 class="title"><a name="d4e622"></a>2.3.10.&nbsp;Queuing of I/O interest set operations</h3></div></div></div>
            
            <p>
            Several older JRE implementations (primarily from IBM) include what Java API 
            documentation refers to as a naive implementation of the <code class="classname">
            java.nio.channels.SelectionKey</code> class. The problem with <code class="classname">
            java.nio.channels.SelectionKey</code> in such JREs is that reading or writing 
            of the I/O interest set may block indefinitely if the I/O selector is in the process 
            of executing a select operation. HttpCore NIO can be configured to operate in a special 
            mode wherein I/O interest set operations are queued and executed by on the dispatch 
            thread only when the I/O selector is not engaged in a select operation.
            </p>
            <pre class="programlisting">
HttpParams params = new BasicHttpParams();
NIOReactorParams.setInterestOpsQueueing(params, true);
ListeningIOReactor ioreactor = new DefaultListeningIOReactor(2, params);
</pre>
        </div>
    </div>
    <div class="section" title="2.4.&nbsp;I/O reactor exception handling"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e628"></a>2.4.&nbsp;I/O reactor exception handling</h2></div></div></div>
        
        <p>
        Protocol specific exceptions as well as those I/O exceptions thrown in the course of 
        interaction with the session's channel are to be expected are to be dealt with by specific 
        protocol handlers. These exceptions may result in termination of an individual session but 
        should not affect the I/O reactor and all other active sessions. There are situations, 
        however, when the I/O reactor itself encounters an internal problem such as an I/O 
        exception in the underlying NIO classes or an unhandled runtime exception. Those types of 
        exceptions are usually fatal and will cause the I/O reactor to shut down automatically.
        </p>
        <p>
        There is a possibility to override this behaviour and prevent I/O reactors from shutting 
        down automatically in case of a runtime exception or an I/O exception in internal classes. 
        This can be accomplished by providing a custom implementation of the <code class="interfacename">
        IOReactorExceptionHandler</code> interface.
        </p>
        <pre class="programlisting">
DefaultConnectingIOReactor ioreactor;

ioreactor.setExceptionHandler(new IOReactorExceptionHandler() {

    public boolean handle(IOException ex) {
        if (ex instanceof BindException) {
            // bind failures considered OK to ignore
            return true;
        }
        return false;
    }

    public boolean handle(RuntimeException ex) {
        if (ex instanceof UnsupportedOperationException) {
            // Unsupported operations considered OK to ignore
            return true;
        }
        return false;
    }
    
});
</pre>
        <p>
        One needs to be very careful about discarding exceptions indiscriminately. It is often much 
        better to let the I/O reactor shut down itself cleanly and restart it rather than leaving 
        it in an inconsistent or unstable state.
        </p>
        <div class="section" title="2.4.1.&nbsp;I/O reactor audit log"><div class="titlepage"><div><div><h3 class="title"><a name="d4e635"></a>2.4.1.&nbsp;I/O reactor audit log</h3></div></div></div>
            
            <p>
            If an I/O reactor is unable to automatically recover from an I/O or a runtime exception 
            it will enter the shutdown mode. First off, it will close all active listeners and 
            cancel all pending new session requests. Then it will attempt to close all active I/O 
            sessions gracefully giving them some time to flush pending output data and terminate 
            cleanly. Lastly, it will forcibly shut down those I/O sessions that still remain active 
            after the grace period. This is a fairly complex process, where many things can fail at 
            the same time and many different exceptions can be thrown in the course of the shutdown 
            process. The I/O reactor will record all exceptions thrown during the shutdown process, 
            including the original one that actually caused the shutdown in the first place, in an 
            audit log. One can examine the audit log and decide whether it is safe to restart the 
            I/O reactor.
            </p>
            <pre class="programlisting">
DefaultConnectingIOReactor ioreactor;

// Give it 5 sec grace period
ioreactor.shutdown(5000);
List&lt;ExceptionEvent&gt; events = ioreactor.getAuditLog();
for (ExceptionEvent event: events) {
    System.err.println("Time: " + event.getTimestamp());
    event.getCause().printStackTrace();
}
</pre>
        </div>
    </div>
    <div class="section" title="2.5.&nbsp;Non-blocking HTTP connections"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e639"></a>2.5.&nbsp;Non-blocking HTTP connections</h2></div></div></div>
        
        <p>
        Effectively non-blocking HTTP connections are wrappers around <code class="interfacename">IOSession
        </code> with HTTP specific functionality. Non-blocking HTTP connections are 
        stateful and not thread-safe. Input / output operations on non-blocking HTTP connections 
        should be restricted to the dispatch events triggered by the I/O event dispatch thread. 
        </p>
        <div class="section" title="2.5.1.&nbsp;Execution context of non-blocking HTTP connections"><div class="titlepage"><div><div><h3 class="title"><a name="d4e643"></a>2.5.1.&nbsp;Execution context of non-blocking HTTP connections</h3></div></div></div>
            
            <p>
            Non-blocking HTTP connections are not bound to a particular thread of execution and 
            therefore they need to maintain their own execution context. Each non-blocking HTTP 
            connection has an <code class="interfacename">HttpContext</code> instance associated with 
            it, which can be used to maintain a processing state. The <code class="interfacename">HttpContext
            </code> instance is thread-safe and can be manipulated from multiple threads.
            </p>
            <pre class="programlisting">
// Get non-blocking HTTP connection
DefaultNHttpClientConnection conn;
// State
Object myStateObject;

HttpContext context = conn.getContext();
context.setAttribute("state", myStateObject);
</pre>
        </div>
        <div class="section" title="2.5.2.&nbsp;Working with non-blocking HTTP connections"><div class="titlepage"><div><div><h3 class="title"><a name="d4e649"></a>2.5.2.&nbsp;Working with non-blocking HTTP connections</h3></div></div></div>
            
            <p>
            At any point of time one can obtain the request and response objects currently being 
            transferred over the non-blocking HTTP connection. Any of these objects, or both, can 
            be null if there is no incoming or outgoing message currently being transferred.
            </p>
            <pre class="programlisting">
NHttpConnection conn;

HttpRequest request = conn.getHttpRequest();
if (request != null) {
    System.out.println("Transferring request: " + 
        request.getRequestLine());
}
HttpResponse response = conn.getHttpResponse();
if (response != null) {
    System.out.println("Transferring response: " + 
        response.getStatusLine());
}
</pre>
            <p>
            However, please note that the current request and the current response may not 
            necessarily represent the same message exchange! Non-blocking HTTP connections can 
            operate in a full duplex mode. One can process incoming and outgoing messages 
            completely independently from one another. This makes non-blocking HTTP connections 
            fully pipelining capable, but at same time implies that this is the job of the protocol 
            handler to match logically related request and the response messages.
            </p>
            <p>
            Over-simplified process of submitting a request on the client side may look like this:
            </p>
            <pre class="programlisting">
// Obtain HTTP connection
NHttpClientConnection conn;

// Obtain execution context
HttpContext context = conn.getContext();

// Obtain processing state
Object state = context.getAttribute("state");

// Generate a request based on the state information
HttpRequest request = new BasicHttpRequest("GET", "/");
    
conn.submitRequest(request);
System.out.println(conn.isRequestSubmitted());
</pre>
            <p>
            Over-simplified process of submitting a response on the server side may look like this:
            </p>
            <pre class="programlisting">
// Obtain HTTP connection
NHttpServerConnection conn;

// Obtain execution context
HttpContext context = conn.getContext();

// Obtain processing state
Object state = context.getAttribute("state");

// Generate a response based on the state information
HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 
    HttpStatus.SC_OK, "OK");
BasicHttpEntity entity = new BasicHttpEntity();
entity.setContentType("text/plain");
entity.setChunked(true);
response.setEntity(entity);
    
conn.submitResponse(response);
System.out.println(conn.isResponseSubmitted());
</pre>
            <p>
            Please note that one should rarely need to transmit messages using these low level 
            methods and should use appropriate higher level HTTP service implementations instead.
            </p>
        </div>
        <div class="section" title="2.5.3.&nbsp;HTTP I/O control"><div class="titlepage"><div><div><h3 class="title"><a name="d4e659"></a>2.5.3.&nbsp;HTTP I/O control</h3></div></div></div>
            
            <p>
            All non-blocking HTTP connections classes implement <code class="interfacename">IOControl
            </code> interface, which represents a subset of connection functionality for 
            controlling interest in I/O even notifications. <code class="interfacename">IOControl
            </code> instances are expected to be fully thread-safe. Therefore 
            <code class="interfacename">IOControl</code> can be used to request / suspend I/O event 
            notifications from any thread. 
            </p>
            <p>
            One must take special precautions when interacting with non-blocking connections. 
            <code class="interfacename">HttpRequest</code> and <code class="interfacename">HttpResponse
            </code>are not thread-safe. It is generally advisable that all input / output 
            operations on a non-blocking connection are executed from the I/O event dispatch 
            thread.   
            </p>
            <p>
            The following pattern is recommended:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p>
                    Use <code class="interfacename">IOControl</code> interface to pass control over 
                    connection's I/O events to another thread / session.
                    </p>
                </li><li class="listitem">
                    <p>
                    If input / output operations need be executed on that particular connection, 
                    store all the required information (state) in the connection context and 
                    request the appropriate I/O operation by calling <code class="methodname">
                    IOControl#requestInput()</code> or <code class="methodname">IOControl#requestOutput()
                    </code> method.
                    </p>
                </li><li class="listitem">
                    <p>
                    Execute the required operations from the event method on the dispatch thread 
                    using information stored in connection context.
                    </p>
                </li></ul></div>
            <p>
            Please note all operations that take place in the event methods should not block for 
            too long, because while the dispatch thread remains blocked in one session, it is 
            unable to process events for all other sessions. I/O operations with the underlying 
            channel of the session are not a problem as they are guaranteed to be non-blocking.  
            </p>
        </div>
        <div class="section" title="2.5.4.&nbsp;Non-blocking content transfer"><div class="titlepage"><div><div><h3 class="title"><a name="d4e680"></a>2.5.4.&nbsp;Non-blocking content transfer</h3></div></div></div>
            
            <p>
            The process of content transfer for non-blocking connections works completely 
            differently compared to that of blocking connections, as non-blocking connections need 
            to accommodate to the asynchronous nature of the NIO model. The main distinction 
            between two types of connections is inability to use the usual, but inherently blocking 
            <code class="classname">java.io.InputStream</code> and <code class="classname">java.io.OutputStream
            </code> classes to represent streams of inbound and outbound content. HttpCore NIO 
            provides <code class="interfacename">ContentEncoder</code> and <code class="interfacename">
            ContentDecoder</code> interfaces to handle the process of asynchronous content 
            transfer. Non-blocking HTTP connections will instantiate the appropriate implementation 
            of a content codec based on properties of the entity enclosed with the message.   
            </p>
            <p>
            Non-blocking HTTP connections will fire input events until the content entity is fully 
            transferred.
            </p>
            <pre class="programlisting">
//Obtain content decoder
ContentDecoder decoder;
//Read data in
ByteBuffer dst = ByteBuffer.allocate(2048); 
decoder.read(dst);
// Decode will be marked as complete when 
// the content entity is fully transferred
if (decoder.isCompleted()) {
    // Done
}
</pre>
            <p>
            Non-blocking HTTP connections will fire output events until the content entity is 
            marked as fully transferred.
            </p>
            <pre class="programlisting">
// Obtain content encoder
ContentEncoder encoder;
// Prepare output data 
ByteBuffer src = ByteBuffer.allocate(2048); 
// Write data out
encoder.write(src);
// Mark content entity as fully transferred when done
encoder.complete();
}
</pre>
            <p>
            Please note, one still has to provide an !HttpEntity instance when submitting an entity 
            enclosing message to the non-blocking HTTP connection. Properties of that entity will 
            be used to initialize an <code class="interfacename">ContentEncoder</code> instance to be 
            used for transferring entity content. Non-blocking HTTP connections, however, ignore 
            inherently blocking <code class="methodname">HttpEntity#getContent()</code> and <code class="methodname">
            HttpEntity#writeTo()</code> methods of the enclosed entities. 
            </p>
            <pre class="programlisting">
// Obtain HTTP connection
NHttpServerConnection conn;

HttpResponse response = new BasicHttpResponse(HttpVersion.HTTP_1_1, 
    HttpStatus.SC_OK, "OK");
BasicHttpEntity entity = new BasicHttpEntity();
entity.setContentType("text/plain");
entity.setChunked(true);
entity.setContent(null);
response.setEntity(entity);
    
conn.submitResponse(response);
</pre>
            <p>
            Likewise, incoming entity enclosing message will have an <code class="interfacename">HttpEntity
            </code> instance associated with them, but an attempt to call <code class="methodname">
            HttpEntity#getContent()</code> or <code class="methodname">HttpEntity#writeTo()</code> 
            methods will cause an <code class="classname">java.lang.IllegalStateException</code>. The 
            <code class="interfacename">HttpEntity</code> instance can be used to determine properties 
            of the incoming entity such as content length.
            </p>
            <pre class="programlisting">
// Obtain HTTP connection
NHttpClientConnection conn;

HttpResponse response = conn.getHttpResponse();
HttpEntity entity = response.getEntity();
if (entity != null) {
    System.out.println(entity.getContentType());
    System.out.println(entity.getContentLength());
    System.out.println(entity.isChunked());
}
</pre>
        </div>
        <div class="section" title="2.5.5.&nbsp;Supported non-blocking content transfer mechanisms"><div class="titlepage"><div><div><h3 class="title"><a name="d4e703"></a>2.5.5.&nbsp;Supported non-blocking content transfer mechanisms</h3></div></div></div>
            
            <p>
            Default implementations of the non-blocking HTTP connection interfaces support three 
            content transfer mechanisms defined by the HTTP/1.1 specification:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p title="Content-Length delimited:">
                    <b><code class="literal">Content-Length</code> delimited:&nbsp;</b>
                    
                    The end of the content entity is determined by the value of the 
                    <code class="literal">Content-Length</code> header. Maximum entity length: 
                    <code class="methodname">Long#MAX_VALUE</code>.
                    
                    </p>
                </li><li class="listitem">
                    <p title="Identity coding:">
                    <b>Identity coding:&nbsp;</b>
                    
                    The end of the content entity is demarcated by closing the underlying 
                    connection (end of stream condition). For obvious reasons the identity encoding 
                    can only be used on the server side. Max entity length: unlimited.
                    
                    </p>
                </li><li class="listitem">
                    <p title="Chunk coding:">
                    <b>Chunk coding:&nbsp;</b>
                    
                    The content is sent in small chunks. Max entity length: unlimited.
                    
                    </p>
                </li></ul></div>
            <p>
            The appropriate content codec will be created automatically depending on properties of 
            the entity enclosed with the message.
            </p>
        </div>
        <div class="section" title="2.5.6.&nbsp;Direct channel I/O"><div class="titlepage"><div><div><h3 class="title"><a name="d4e723"></a>2.5.6.&nbsp;Direct channel I/O</h3></div></div></div>
            
            <p>
            Content codes are optimized to read data directly from or write data directly to the 
            underlying I/O session's channel, whenever possible avoiding intermediate buffering in 
            a session buffer. Moreover, those codecs that do not perform any content transformation 
            such as <code class="literal">Content-Length</code> delimited and identity can leverage NIO 
            <code class="classname">java.nio.FileChannel</code> methods for significantly improved 
            performance of file transfer operations both inbound and outbound.  
            </p>
            <p>
            If the actual content decoder implements <code class="interfacename">FileContentDecoder
            </code> one can make use of its methods to read incoming content directly to a 
            file bypassing an intermediate <code class="classname">java.nio.ByteBuffer</code>.
            </p>
            <pre class="programlisting">
//Obtain content decoder
ContentDecoder decoder;
//Prepare file channel
FileChannel dst;
//Make use of direct file I/O if possible
if (decoder instanceof FileContentDecoder) {
    long Bytesread = ((FileContentDecoder) decoder)
        .transfer(dst, 0, 2048);
     // Decode will be marked as complete when 
     // the content entity is fully transmitted
     if (decoder.isCompleted()) {
         // Done
     }
}
</pre>
            <p>
            If the actual content encoder implements <code class="interfacename">FileContentEncoder
            </code> one can make use of its methods to write outgoing content directly 
            from a file bypassing an intermediate <code class="classname">java.nio.ByteBuffer</code>.
            </p>
            <pre class="programlisting">
// Obtain content encoder
ContentEncoder encoder;
// Prepare file channel
FileChannel src;
// Make use of direct file I/O if possible
if (encoder instanceof FileContentEncoder) {
    // Write data out
    long bytesWritten = ((FileContentEncoder) encoder)
        .transfer(src, 0, 2048); 
    // Mark content entity as fully transferred when done
    encoder.complete();
}
</pre>
        </div>
    </div>
    <div class="section" title="2.6.&nbsp;HTTP I/O event dispatchers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e736"></a>2.6.&nbsp;HTTP I/O event dispatchers</h2></div></div></div>
        
        <p>
        HTTP I/O event dispatchers serve to convert generic I/O events triggered by an I/O reactor 
        to HTTP protocol specific events. They rely on <code class="interfacename">NHttpClientHandler
        </code> and <code class="interfacename">NHttpServiceHandler</code> interfaces to 
        propagate HTTP protocol events to a HTTP protocol handler.
        </p>
        <p>
        Server side HTTP I/O events as defined by the <code class="interfacename">NHttpServiceHandler
        </code> interface:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                <p title="connected:">
                <b><code class="methodname">connected</code>:&nbsp;</b>
                
                Triggered when a when a new incoming connection has been created.
                
                </p>
            </li><li class="listitem">
                <p title="requestReceived:">
                <b><code class="methodname">requestReceived</code>:&nbsp;</b>
                
                Triggered when a new HTTP request is received. The connection passed as a parameter to 
                this method is guaranteed to return a valid HTTP request object. If the request 
                received encloses a request entity this method will be followed a series of 
                <code class="methodname">inputReady</code> events to transfer the request content.
                
                </p>
            </li><li class="listitem">
                <p title="inputReady:">
                <b><code class="methodname">inputReady</code>:&nbsp;</b>
                
                Triggered when the underlying channel is ready for reading a new portion of the request 
                entity through the corresponding content decoder. If the content consumer is unable to 
                process the incoming content, input event notifications can be temporarily suspended 
                using <code class="interfacename">IOControl</code> interface.
                
                </p>
            </li><li class="listitem">
                <p title="responseReady:">
                <b><code class="methodname">responseReady</code>:&nbsp;</b>
                
                Triggered when the connection is ready to accept new HTTP response. The protocol 
                handler does not have to submit a response if it is not ready.
                
                </p>
            </li><li class="listitem">
                <p title="outputReady:">
                <b><code class="methodname">outputReady</code>:&nbsp;</b>
                
                Triggered when the underlying channel is ready for writing a next portion of the 
                response entity through the corresponding content encoder. If the content producer is 
                unable to generate the outgoing content, output event notifications can be temporarily 
                suspended using <code class="interfacename">IOControl</code> interface.
                
                </p>
            </li><li class="listitem">
                <p title="exception:">
                <b><code class="methodname">exception</code>:&nbsp;</b>
                
                Triggered when an I/O error occurrs while reading from or writing to the underlying 
                channel or when an HTTP protocol violation occurs while receiving an HTTP request.
                
                </p>
            </li><li class="listitem">
                <p title="exception:">
                <b><code class="methodname">exception</code>:&nbsp;</b>
                
                Triggered when an I/O error occurrs while reading from or writing to the underlying 
                channel or when an HTTP protocol violation occurs while receiving an HTTP request.
                
                </p>
            </li><li class="listitem">
                <p title="timeout:">
                <b><code class="methodname">timeout</code>:&nbsp;</b>
                
                Triggered when no input is detected on this connection over the maximum period of 
                inactivity.
                
                </p>
            </li><li class="listitem">
                <p title="closed:">
                <b><code class="methodname">closed</code>:&nbsp;</b>
                
                Triggered when the connection has been closed.
                
                </p>
            </li></ul></div>
        <p>
        Client side HTTP I/O events as defined by the <code class="interfacename">NHttpClientHandler
        </code> interface:
        </p>
        <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                <p title="connected:">
                <b><code class="methodname">connected</code>:&nbsp;</b>
                
                Triggered when a new outgoing connection has been created. The attachment object passed 
                as a parameter to this event is an arbitrary object that was attached to the session 
                request.
                
                </p>
            </li><li class="listitem">
                <p title="requestReady:">
                <b><code class="methodname">requestReady</code>:&nbsp;</b>
                
                Triggered when the connection is ready to accept new HTTP request. The protocol handler 
                does not have to submit a request if it is not ready.
                
                </p>
            </li><li class="listitem">
                <p title="outputReady:">
                <b><code class="methodname">outputReady</code>:&nbsp;</b>
                
                Triggered when the underlying channel is ready for writing a next portion of the 
                request entity through the corresponding content encoder. If the content producer is 
                unable to generate the outgoing content, output event notifications can be temporarily 
                suspended using <code class="interfacename">IOControl</code> interface.
                
                </p>
            </li><li class="listitem">
                <p title="responseReceived:">
                <b><code class="methodname">responseReceived</code>:&nbsp;</b>
                
                Triggered when an HTTP response is received. The connection passed as a parameter to 
                this method is guaranteed to return a valid HTTP response object. If the response 
                received encloses a response entity this method will be followed a series of 
                <code class="methodname">inputReady</code> events to transfer the response content.
                
                </p>
            </li><li class="listitem">
                <p title="inputReady:">
                <b><code class="methodname">inputReady</code>:&nbsp;</b>
                
                Triggered when the underlying channel is ready for reading a new portion of the 
                response entity through the corresponding content decoder. If the content consumer is 
                unable to process the incoming content, input event notifications can be temporarily 
                suspended using <code class="interfacename">IOControl</code> interface.
                
                </p>
            </li><li class="listitem">
                <p title="exception:">
                <b><code class="methodname">exception</code>:&nbsp;</b>
                
                Triggered when an I/O error occurs while reading from or writing to the underlying 
                channel or when an HTTP protocol violation occurs while receiving an HTTP response..
                
                </p>
            </li><li class="listitem">
                <p title="exception:">
                <b><code class="methodname">exception</code>:&nbsp;</b>
                
                Triggered when an I/O error occurrs while reading from or writing to the underlying 
                channel or when an HTTP protocol violation occurs while receiving an HTTP request.
                
                </p>
            </li><li class="listitem">
                <p title="timeout:">
                <b><code class="methodname">timeout</code>:&nbsp;</b>
                
                Triggered when no input is detected on this connection over the maximum period of 
                inactivity.
                
                </p>
            </li><li class="listitem">
                <p title="closed:">
                <b><code class="methodname">closed</code>:&nbsp;</b>
                
                Triggered when the connection has been closed.
                
                </p>
            </li></ul></div>
    </div>
    <div class="section" title="2.7.&nbsp;Non-blocking HTTP entities"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e843"></a>2.7.&nbsp;Non-blocking HTTP entities</h2></div></div></div>
        
        <p>
        As discussed previously the process of content transfer for non-blocking connections works 
        completely differently compared to that for blocking connections. For obvious reasons 
        classic I/O abstraction based on inherently blocking <code class="classname">java.io.InputStream
        </code> and <code class="classname">java.io.OutputStream</code> classes is not applicable to 
        the asynchronous process of data transfer. Therefore, non-blocking HTTP entities provide 
        NIO specific extensions to the !HttpEntity interface: <code class="interfacename">ProducingNHttpEntity
        </code> and <code class="interfacename">ConsumingNHttpEntity</code> interfaces. 
        Implementation classes of these interfaces may throw <code class="classname">
        java.lang.UnsupportedOperationException</code> from <code class="methodname">
        HttpEntity#getContent()</code> or <code class="methodname">HttpEntity#writeTo()</code> if 
        a particular implementation is unable to represent its content stream as instance of 
        <code class="classname">java.io.InputStream</code> or cannot stream its content out to an 
        <code class="classname">java.io.OutputStream</code>.
        </p>
        <div class="section" title="2.7.1.&nbsp;Content consuming non-blocking HTTP entity"><div class="titlepage"><div><div><h3 class="title"><a name="d4e855"></a>2.7.1.&nbsp;Content consuming non-blocking HTTP entity</h3></div></div></div>
            
            <p>
            <code class="interfacename">ConsumingNHttpEntity</code> interface represents a non-blocking 
            entity that allows content to be consumed from a content decoder. <code class="interfacename">
            ConsumingNHttpEntity</code> extends the base <code class="interfacename">HttpEntity
            </code> interface with a number of NIO specific notification methods:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p title="consumeContent:">
                    <b><code class="methodname">consumeContent</code>:&nbsp;</b>
                    
                    Notification that content is available to be read from the decoder. 
                    <code class="interfacename">IOControl</code> instance passed as a parameter to the 
                    method can be used to suspend input events if the entity is temporarily unable 
                    to allocate more storage to accommodate all incoming content.
                    
                    </p>
                </li><li class="listitem">
                    <p title="finish:">
                    <b><code class="methodname">finish</code>:&nbsp;</b>
                    
                    Notification that any resources allocated for reading can be released.
                    
                    </p>
                </li></ul></div>
            <p>
            The following implementations of <code class="interfacename">ConsumingNHttpEntity</code> 
            provided by HttpCore NIO:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p>
                    <a class="link" href="nio.html#buffering-n-entity" title="2.7.1.1.&nbsp;BufferingNHttpEntity">
                        <code class="classname">BufferingNHttpEntity</code>
                    </a>
                    </p>
                </li><li class="listitem">
                    <p>
                    <a class="link" href="nio.html#consuming-n-entity-template" title="2.7.1.2.&nbsp;ConsumingNHttpEntityTemplate">
                        <code class="classname">ConsumingNHttpEntityTemplate</code>
                    </a>
                    </p>
                </li></ul></div>
            <div class="section" title="2.7.1.1.&nbsp;BufferingNHttpEntity"><div class="titlepage"><div><div><h4 class="title"><a name="buffering-n-entity"></a>2.7.1.1.&nbsp;<code class="classname">BufferingNHttpEntity</code></h4></div></div></div>
                
                <p>
                <code class="classname">BufferingNHttpEntity</code> is a subclass of <code class="classname">
                HttpEntityWrapper</code> that consumes all incoming content into memory. Once 
                the content body has been fully received it can be retrieved as an <code class="classname">
                java.io.InputStream</code> via <code class="methodname">HttpEntity#getContent()
                </code>, or written to an output stream via <code class="methodname">HttpEntity#writeTo()
                </code>.
                </p>
            </div>
            <div class="section" title="2.7.1.2.&nbsp;ConsumingNHttpEntityTemplate"><div class="titlepage"><div><div><h4 class="title"><a name="consuming-n-entity-template"></a>2.7.1.2.&nbsp;<code class="classname">ConsumingNHttpEntityTemplate</code></h4></div></div></div>
                
                <p>
                <code class="classname">ConsumingNHttpEntityTemplate</code> is a subclass of <code class="classname">
                HttpEntityWrapper</code> that that decorates the incoming HTTP entity and 
                delegates the handling of incoming content to a <code class="interfacename">ContentListener
                </code> instance.
                </p>
                <pre class="programlisting">
static class FileWriteListener implements ContentListener {

    private final FileChannel fileChannel;
    private long idx = 0;

    public FileWriteListener(File file) throws IOException {
        this.fileChannel = new FileInputStream(file).getChannel();
    }

    public void contentAvailable(
    ContentDecoder decoder, IOControl ioctrl) throws IOException {
        long transferred;
        if (decoder instanceof FileContentDecoder) {
            transferred = ((FileContentDecoder) decoder).transfer(
                    fileChannel, idx, Long.MAX_VALUE);
        } else {
            transferred = fileChannel.transferFrom(
                    new ContentDecoderChannel(decoder), 
                    idx, Long.MAX_VALUE);
        }
        if (transferred &gt; 0) {
            idx += transferred;
        }
    }

    public void finished() {
        try {
            fileChannel.close();
        } catch(IOException ignored) {}
    }
    
}

HttpEntity incomingEntity;

File file = new File("buffer.bin");
ConsumingNHttpEntity entity = new ConsumingNHttpEntityTemplate(
        incomingEntity, 
        new FileWriteListener(file)); 
</pre>
            </div>
        </div>
        <div class="section" title="2.7.2.&nbsp;Content producing non-blocking HTTP entity"><div class="titlepage"><div><div><h3 class="title"><a name="d4e901"></a>2.7.2.&nbsp;Content producing non-blocking HTTP entity</h3></div></div></div>
            
            <p>
            <code class="interfacename">ProducingNHttpEntity</code> interface represents a non-blocking 
            entity that allows content to be written to a content encoder. 
            <code class="interfacename">ProducingNHttpEntity</code> extends the base 
            <code class="interfacename">HttpEntity</code> interface with a number of NIO specific 
            notification methods:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p title="produceContent:">
                    <b><code class="methodname">produceContent</code>:&nbsp;</b>
                    
                    Notification that content can be written to the encoder. <code class="interfacename">
                    IOControl</code> instance passed as a parameter to the method can be 
                    used to temporarily suspend output events if the entity is unable to produce 
                    more content. Please note one must call <code class="methodname">ContentEncoder#complete()
                    </code> to inform the underlying connection that all content has been 
                    written. Failure to do so could result in the entity never being correctly 
                    delimited.
                    
                    </p>
                </li><li class="listitem">
                    <p title="finish:">
                    <b><code class="methodname">finish</code>:&nbsp;</b>
                    
                    Notification that any resources allocated for writing can be released.
                    
                    </p>
                </li></ul></div>
            <p>
            The following implementations of <code class="interfacename">ProducingNHttpEntity</code> 
            provided by HttpCore NIO:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p>
                    <a class="link" href="nio.html#bytearray-n-entity" title="2.7.2.1.&nbsp;NByteArrayEntity">
                        <code class="classname">NByteArrayEntity</code>
                    </a>
                    </p>
                </li><li class="listitem">
                    <p>
                    <a class="link" href="nio.html#string-n-entity" title="2.7.2.2.&nbsp;NStringEntity">
                        <code class="classname">NStringEntity</code>
                    </a>
                    </p>
                </li><li class="listitem">
                    <p>
                    <a class="link" href="nio.html#file-n-entity" title="2.7.2.3.&nbsp;NFileEntity">
                        <code class="classname">NFileEntity</code>
                    </a>
                    </p>
                </li></ul></div>
            <div class="section" title="2.7.2.1.&nbsp;NByteArrayEntity"><div class="titlepage"><div><div><h4 class="title"><a name="bytearray-n-entity"></a>2.7.2.1.&nbsp;<code class="classname">NByteArrayEntity</code></h4></div></div></div>
                
                <p>
                This is a simple self contained repeatable entity, which receives its content from 
                a given byte array. This byte array is supplied to the constructor.
                </p>
                <pre class="programlisting">
String myData = "Hello world on the other side!!";
NByteArrayEntity entity = new NByteArrayEntity(myData.getBytes()); 
</pre>
            </div>
            <div class="section" title="2.7.2.2.&nbsp;NStringEntity"><div class="titlepage"><div><div><h4 class="title"><a name="string-n-entity"></a>2.7.2.2.&nbsp;<code class="classname">NStringEntity</code></h4></div></div></div>
                
                <p>
                It's is a simple, self contained, repeatable entity that retrieves its data from a 
                <code class="classname">java.lang.String</code> object. It has 2 constructors, one simply 
                constructs with a given string where the other also takes a character encoding for 
                the data in the <code class="classname">java.lang.String</code>.
                </p>
                <pre class="programlisting">
String myData = "Hello world on the other side!!";
// construct without a character encoding
NStringEntity myEntity1 = new NStringEntity(myData);
// alternatively construct with an encoding
NStringEntity myEntity2 = new NStringEntity(myData, "UTF-8");
</pre>
            </div>
            <div class="section" title="2.7.2.3.&nbsp;NFileEntity"><div class="titlepage"><div><div><h4 class="title"><a name="file-n-entity"></a>2.7.2.3.&nbsp;<code class="classname">NFileEntity</code></h4></div></div></div>
                
                <p>
                This entity reads its content body from a file. This class is mostly used to stream 
                large files of different types, so one needs to supply the content type of the file 
                to make sure the content can be correctly recognized and processed by the 
                recipient.
                </p>
                <pre class="programlisting">
File staticFile = new File("/path/to/myapp.jar");
NHttpEntity entity = new NFileEntity(staticFile, 
    "application/java-archive");
</pre>
                <p>
                The <code class="classname">NHttpEntity</code> will make use of the direct channel I/O 
                whenever possible, provided the content encoder is capable of transferring data 
                directly from a file to the socket of the underlying connection.
                </p>
            </div>
        </div>
    </div>
    <div class="section" title="2.8.&nbsp;Non-blocking HTTP protocol handlers"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e954"></a>2.8.&nbsp;Non-blocking HTTP protocol handlers</h2></div></div></div>
        
        <div class="section" title="2.8.1.&nbsp;Asynchronous HTTP service handler"><div class="titlepage"><div><div><h3 class="title"><a name="d4e956"></a>2.8.1.&nbsp;Asynchronous HTTP service handler</h3></div></div></div>
            
            <p>
            <code class="classname">AsyncNHttpServiceHandler</code> is a fully asynchronous HTTP server 
            side protocol handler that implements the essential requirements of the HTTP protocol 
            for the server side message processing as described by RFC 2616. <code class="classname">
            AsyncNHttpServiceHandler</code> is capable of processing HTTP requests with nearly 
            constant memory footprint for individual HTTP connections. The handler stores headers 
            of HTTP messages in memory, while content of message bodies is streamed directly from 
            the entity to the underlying channel (and vice versa) using <code class="interfacename">
            ConsumingNHttpEntity</code> and <code class="interfacename">ProducingNHttpEntity
            </code> interfaces. 
            </p>
            <p>
            When using this implementation, it is important to ensure that entities supplied for 
            writing implement <code class="interfacename">ProducingNHttpEntity</code>. Doing so will 
            allow the entity to be written out asynchronously. If entities supplied for writing do 
            not implement the <code class="interfacename">ProducingNHttpEntity</code> interface, 
            a delegate is added that buffers the entire contents in memory. Additionally, 
            the buffering might take place in the I/O dispatch thread, which could cause I/O to 
            block temporarily. For best results, one must ensure that all entities set on 
            HTTP responses from <code class="interfacename">NHttpRequestHandler</code> implement 
            <code class="interfacename">ProducingNHttpEntity</code>.
            </p>
            <p>
            If incoming requests enclose a content entity, <code class="interfacename">NHttpRequestHandler
            </code> instances are expected to return a <code class="interfacename">ConsumingNHttpEntity
            </code> for reading the content. After the entity is finished reading the 
            data, <code class="methodname">NHttpRequestHandler#handle()</code> method is called to 
            generate a response. 
            </p>
            <p>
            <code class="classname">AsyncNHttpServiceHandler</code> relies on <code class="interfacename">HttpProcessor
            </code> to generate mandatory protocol headers for all outgoing messages and 
            apply common, cross-cutting message transformations to all incoming and outgoing 
            messages, whereas individual HTTP request handlers are expected to take care of 
            application specific content generation and processing.
            </p>
            <pre class="programlisting">
HttpParams params;
// Initialize HTTP parameters
HttpProcessor httpproc;
// Initialize HTTP processor

AsyncNHttpServiceHandler handler = new AsyncNHttpServiceHandler(
        httpproc,
        new DefaultHttpResponseFactory(),
        new DefaultConnectionReuseStrategy(),
        params);
</pre>
            <div class="section" title="2.8.1.1.&nbsp;Non-blocking HTTP request handlers"><div class="titlepage"><div><div><h4 class="title"><a name="d4e976"></a>2.8.1.1.&nbsp;Non-blocking HTTP request handlers</h4></div></div></div>
                
                <p>
                <code class="interfacename">NHttpRequestHandler</code> interface represents a routine 
                for processing of a specific group of non-blocking HTTP requests. <code class="interfacename">
                NHttpRequestHandler</code> implementations are expected to take care of 
                protocol specific aspects, whereas individual request handlers are expected take 
                care of application specific HTTP processing. The main purpose of a request handler 
                is to generate a response object with a content entity to be send back to the 
                client in response to the given request.
                </p>
                <pre class="programlisting">
NHttpRequestHandler myRequestHandler = new NHttpRequestHandler() {

    public ConsumingNHttpEntity entityRequest(
            HttpEntityEnclosingRequest request, 
            HttpContext context) throws HttpException, IOException {
        // Buffer imcoming content in memory for simplicity 
        return new BufferingNHttpEntity(request.getEntity(),
                new HeapByteBufferAllocator());
    }

    public void handle(
            HttpRequest request, 
            HttpResponse response,
            NHttpResponseTrigger trigger,
            HttpContext context) throws HttpException, IOException {
        response.setStatusCode(HttpStatus.SC_OK);
        response.addHeader("Content-Type", "text/plain");
        response.setEntity(
            new NStringEntity("some important message"));
        // Submit response immediately for simplicity
        trigger.submitResponse(response);
    }
    
};
</pre>
                <p>
                Request handlers must be implemented in a thread-safe manner. Similarly to 
                servlets, request handlers should not use instance variables unless access to those 
                variables are synchronized.
                </p>
            </div>
            <div class="section" title="2.8.1.2.&nbsp;Asynchronous response trigger"><div class="titlepage"><div><div><h4 class="title"><a name="d4e983"></a>2.8.1.2.&nbsp;Asynchronous response trigger</h4></div></div></div>
                
                <p>
                The most fundamental difference of the non-blocking request handlers compared to 
                their blocking counterparts is ability to defer transmission of the HTTP response 
                back to the client without blocking the I/O thread by delegating the process of 
                handling the HTTP request to a worker thread. The worker thread can use the 
                instance of <code class="interfacename">NHttpResponseTrigger</code> passed as a 
                parameter to the <code class="methodname">NHttpRequestHandler#handle</code> method to 
                submit a response as at a later point of time once the response becomes available.
                </p>
                <pre class="programlisting">
NHttpRequestHandler myRequestHandler = new NHttpRequestHandler() {

    public ConsumingNHttpEntity entityRequest(
            HttpEntityEnclosingRequest request, 
            HttpContext context) throws HttpException, IOException {
        // Buffer imcoming content in memory for simplicity 
        return new BufferingNHttpEntity(request.getEntity(),
                new HeapByteBufferAllocator());
    }

    public void handle(
            HttpRequest request, 
            HttpResponse response,
            NHttpResponseTrigger trigger,
            HttpContext context) 
                throws HttpException, IOException {
        new Thread() {
            
        @Override
        public void run() {
            try { 
                Thread.sleep(10); 
            } 
            catch(InterruptedException ie) {}
            try {
                URI uri = new URI(request.getRequestLine().getUri());
                response.setStatusCode(HttpStatus.SC_OK);
                response.addHeader("Content-Type", "text/plain");
                response.setEntity(
                    new NStringEntity("some important message"));
                trigger.submitResponse(response);                    
            } catch(URISyntaxException ex) {
                trigger.handleException(
                    new HttpException("Invalid request URI: " + 
                    ex.getInput()));
            }
        }
            
        }.start();
    }
    
};
</pre>
                <p>
                Please note <code class="interfacename">HttpResponse</code> objects are not thread-safe 
                and may not be modified concurrently. Non-blocking request handlers must ensure 
                the HTTP response cannot be accessed by more than one thread at a time.
                </p>
            </div>
            <div class="section" title="2.8.1.3.&nbsp;Non-blocking request handler resolver"><div class="titlepage"><div><div><h4 class="title"><a name="d4e991"></a>2.8.1.3.&nbsp;Non-blocking request handler resolver</h4></div></div></div>
                
                <p>
                The management of non-blocking HTTP request handlers is quite similar to that of 
                blocking HTTP request handlers. Usually an instance of <code class="interfacename">
                NHttpRequestHandlerResolver</code> is used to maintain a registry of 
                request handlers and to matches a request URI to a particular request handler. 
                HttpCore includes only a very simple implementation of the request handler resolver 
                based on a trivial pattern matching algorithm: <code class="interfacename">
                NHttpRequestHandlerRegistry</code> supports only three formats: 
                <code class="literal">*</code>, <code class="literal">&lt;uri&gt;*</code> and 
                <code class="literal">*&lt;uri&gt;</code>.
                </p>
                <pre class="programlisting">
// Initialize asynchronous protocol handler
AsyncNHttpServiceHandler handler;

NHttpRequestHandlerRegistry handlerResolver = 
    new NHttpRequestHandlerRegistry();
handlerReqistry.register("/service/*", myRequestHandler1);
handlerReqistry.register("*.do", myRequestHandler2);
handlerReqistry.register("*", myRequestHandler3);

handler.setHandlerResolver(handlerResolver);
</pre>
                <p>
                Users are encouraged to provide more sophisticated implementations of 
                <code class="interfacename">NHttpRequestHandlerResolver</code>, for instance, based on 
                regular expressions.
                </p>
            </div>
        </div>
        <div class="section" title="2.8.2.&nbsp;Asynchronous HTTP client handler"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1002"></a>2.8.2.&nbsp;Asynchronous HTTP client handler</h3></div></div></div>
            
            <p>
            <code class="classname">AsyncNHttpClientHandler</code> is a fully asynchronous HTTP client side 
            protocol handler that implements the essential requirements of the HTTP protocol for 
            the client side message processing as described by RFC 2616. <code class="classname">
            AsyncNHttpClientHandler</code> is capable of executing HTTP requests with nearly 
            constant memory footprint for individual HTTP connections. The handler stores headers 
            of HTTP messages in memory, while content of message bodies is streamed directly from 
            the entity to the underlying channel (and vice versa) using <code class="interfacename">
            ConsumingNHttpEntity</code> and <code class="interfacename">ProducingNHttpEntity
            </code> interfaces. 
            </p>
            <p>
            When using this implementation, it is important to ensure that entities supplied for 
            writing implement <code class="interfacename">ProducingNHttpEntity</code>. Doing so will 
            allow the entity to be written out asynchronously. If entities supplied for writing do 
            not implement the <code class="interfacename">ProducingNHttpEntity</code> interface, 
            a delegate is added that buffers the entire contents in memory. Additionally, the 
            buffering might take place in the I/O dispatch thread, which could cause I/O to block 
            temporarily. For best results, one must ensure that all entities set on HTTP requests 
            from <code class="interfacename">NHttpRequestExecutionHandler</code> implement 
            <code class="interfacename">ProducingNHttpEntity</code>.
            </p>
            <p>
            If incoming responses enclose a content entity, <code class="interfacename">
            NHttpRequestExecutionHandler</code> is expected to return a <code class="interfacename">
            ConsumingNHttpEntity</code> for reading the content. After the entity is 
            finished reading the data, <code class="methodname">NHttpRequestExecutionHandler#handleResponse()
            </code>method is called to process the response. 
            </p>
            <p>
            If incoming responses enclose a content entity, <code class="interfacename">
            NHttpRequestExecutionHandler</code> is expected to return a <code class="interfacename">
            ConsumingNHttpEntity</code> for reading the content. After the entity is 
            finished reading the data, <code class="methodname">NHttpRequestExecutionHandler#handleResponse()
            </code>method is called to process the response. 
            </p>
            <p>
            <code class="classname">AsyncNHttpClientHandler</code> relies on <code class="interfacename">HttpProcessor
            </code>to generate mandatory protocol headers for all outgoing messages and 
            apply common, cross-cutting message transformations to all incoming and outgoing 
            messages, whereas HTTP request executor is expected to take care of application 
            specific content generation and processing.
            </p>
            <pre class="programlisting">
//  Initialize HTTP parameters
HttpParams params;
//Initialize HTTP processor
HttpProcessor httpproc;
//Create HTTP request execution handler
NHttpRequestExecutionHandler execHandler;

AsyncNHttpClientHandler handler = new AsyncNHttpClientHandler(
         httpproc,
         execHandler,
         new DefaultConnectionReuseStrategy(),
         params);
</pre>
            <div class="section" title="2.8.2.1.&nbsp;Asynchronous HTTP request execution handler"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1026"></a>2.8.2.1.&nbsp;Asynchronous HTTP request execution handler</h4></div></div></div>
                
                <p>
                Asynchronous HTTP request execution handler can be used by client-side protocol 
                handlers to trigger the submission of a new HTTP request and the processing of an 
                HTTP response. 
                </p>
                <p>
                HTTP request execution exents as defined by the <code class="interfacename">
                NHttpRequestExecutionHandler</code> interface:
                </p>
                <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                        <p title="initalizeContext:">
                        <b><code class="methodname">initalizeContext</code>:&nbsp;</b>
                        
                        Triggered when a new connection has been established and the HTTP context 
                        needs to be initialized. The attachment object passed to this method is 
                        the same object which was passed to the connecting I/O reactor when the 
                        connection request was made. The attachment may optionally contain some 
                        state information required in order to correctly initialize the HTTP 
                        context.
                        
                        </p>
                    </li><li class="listitem">
                        <p title="submitRequest:">
                        <b><code class="methodname">submitRequest</code>:&nbsp;</b>
                        
                        Triggered when the underlying connection is ready to send a new HTTP 
                        request to the target host. This method may return null if the client is 
                        not yet ready to send a request. In this case the connection will remain 
                        open and can be activated at a later point. If the request encloses an 
                        entity, the entity must be an instance of <code class="interfacename">
                        ProducingNHttpEntity</code>.
                        
                        </p>
                    </li><li class="listitem">
                        <p title="responseEntity:">
                        <b><code class="methodname">responseEntity</code>:&nbsp;</b>
                        
                        Triggered when a response is received with an entity. This method should 
                        return a <code class="interfacename">ConsumingNHttpEntity</code> that will be 
                        used to consume the entity. Null is a valid response value, and will 
                        indicate that the entity should be silently ignored. After the entity is 
                        fully consumed, <code class="methodname">handleResponse</code> method is called 
                        to notify a full response and enclosed entity are ready to be processed.
                        
                        </p>
                    </li><li class="listitem">
                        <p title="handleResponse:">
                        <b><code class="methodname">handleResponse</code>:&nbsp;</b>
                        
                        Triggered when an HTTP response is ready to be processed.
                        
                        </p>
                    </li><li class="listitem">
                        <p title="finalizeContext:">
                        <b><code class="methodname">finalizeContext</code>:&nbsp;</b>
                        
                        Triggered when the connection is terminated. This event can be used to 
                        release objects stored in the context or perform some other kind of 
                        cleanup.
                        
                        </p>
                    </li></ul></div>
            <pre class="programlisting">
NHttpRequestExecutionHandler execHandler = 
    new NHttpRequestExecutionHandler() {

    private final static String DONE_FLAG = "done";
    
    public void initalizeContext(
        HttpContext context, 
        Object attachment) {
        if (attachment != null) {
            HttpHost virtualHost = (HttpHost) attachment;
            context.setAttribute(ExecutionContext.HTTP_TARGET_HOST, 
                virtualHost);
        }
    }

    public void finalizeContext(HttpContext context) {
        context.removeAttribute(DONE_FLAG);
    }

    public HttpRequest submitRequest(HttpContext context) {
        // Submit HTTP GET once
        Object done = context.getAttribute(DONE_FLAG);
        if (done == null) {
            context.setAttribute(DONE_FLAG, Boolean.TRUE);
            return new BasicHttpRequest("GET", "/");
        } else {
            return null;
        }
    }
    
    public ConsumingNHttpEntity responseEntity(
        HttpResponse response, 
        HttpContext context) throws IOException {
        // Buffer imcoming content in memory for simplicity 
        return new BufferingNHttpEntity(response.getEntity(),
                new HeapByteBufferAllocator());
    }

    public void handleResponse(
        HttpResponse response, 
        HttpContext context) throws IOException {
        System.out.println(response.getStatusLine());
        if (response.getEntity() != null) {
            System.out.println(
                EntityUtils.toString(response.getEntity()));
        }
    }

};
</pre>
            </div>
        </div>
        <div class="section" title="2.8.3.&nbsp;Compatibility with blocking I/O"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1061"></a>2.8.3.&nbsp;Compatibility with blocking I/O</h3></div></div></div>
            
            <p>
            In addition to asynchronous protocol handlers described above HttpCore ships two 
            variants of HTTP protocol handlers that emulate blocking I/O model on top of 
            non-blocking one and allow message content to be produced and consumed using standard 
            <code class="classname">java.io.OutputStream</code> / <code class="classname">java.io.InputStream</code> 
            API. Compatibility protocol handlers can work with HTTP request handlers and request 
            executors that rely on blocking HttpEntity implementations.
            </p>
            <p>
            Compatibility protocol handlers rely on !HttpProcessor to generate mandatory protocol 
            headers for all outgoing messages and apply common, cross-cutting message 
            transformations to all incoming and outgoing messages, whereas individual HTTP request 
            executors / HTTP request processors are expected to take care of application specific 
            content generation and processing.
            </p>
            <div class="section" title="2.8.3.1.&nbsp;Buffering protocol handlers"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1067"></a>2.8.3.1.&nbsp;Buffering protocol handlers</h4></div></div></div>
                
                <p>
                <code class="classname">BufferingHttpServiceHandler</code> and <code class="classname">
                BufferingHttpClientHandler</code> are protocol handler implementations that 
                provide compatibility with the blocking I/O by storing the full content of HTTP 
                messages in memory. Request / response processing callbacks fire only when the 
                entire message content has been read into a in-memory buffer. Please note that 
                request execution / request processing take place the main I/O thread and therefore 
                individual HTTP request executors / request handlers must ensure they do not block 
                indefinitely. 
                </p>
                <p>
                Buffering  protocol handler should be used only when dealing with HTTP messages 
                that are known to be limited in length.
                </p>
            </div>
            <div class="section" title="2.8.3.2.&nbsp;Throttling protocol handlers"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1073"></a>2.8.3.2.&nbsp;Throttling protocol handlers</h4></div></div></div>
                
                <p>
                <code class="classname">ThrottlingHttpServiceHandler</code> and <code class="classname">
                ThrottlingHttpClientHandler</code> are protocol handler implementations that 
                provide compatibility with the blocking I/O model by utilizing shared content 
                buffers and a fairly small pool of worker threads. The throttling protocol handlers 
                allocate input / output buffers of a constant length upon initialization and 
                control the rate of I/O events in order to ensure those content buffers does not 
                ever overflow. This helps ensure nearly constant memory footprint for HTTP 
                connections and avoid out of memory conditions while streaming content in and out. 
                Request / response processing callbacks fire immediately when a message is 
                received. The throttling protocol handlers delegate the task of processing requests 
                and generating response content to an !Executor, which is expected to perform those 
                tasks using dedicated worker threads in order to avoid blocking the I/O thread.
                </p>
                <p>
                Usually throttling protocol handlers need only a modest number of worker threads, 
                much fewer than the number of concurrent connections. If the length of the message 
                is smaller or about the size of the shared content buffer worker thread will just 
                store content in the buffer and terminate almost immediately without blocking. 
                The I/O dispatch thread in its turn will take care of sending out the buffered 
                content asynchronously. The worker thread will have to block only when processing 
                large messages and the shared buffer fills up. It is generally advisable to 
                allocate shared buffers of a size of an average content body for optimal 
                performance.
                </p>
            </div>
        </div>
        <div class="section" title="2.8.4.&nbsp;Connection event listener"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1079"></a>2.8.4.&nbsp;Connection event listener</h3></div></div></div>
            
            <p>
            Protocol handlers like the rest of HttpCore classes do not do logging in order to not 
            impose a choice of a logging framework onto the users. However one can add logging of 
            the most important connection events by injecting a <code class="interfacename">EventListener
            </code> implementation into the protocol handler.
            </p>
            <p>
            Connection events as defined by the <code class="interfacename">EventListener</code> 
            interface:
            </p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p title="fatalIOException:">
                    <b><code class="methodname">fatalIOException</code>:&nbsp;</b>
                    
                    Triggered when an I/O error caused the connection to be terminated.
                    
                    </p>
                </li><li class="listitem">
                    <p title="fatalProtocolException:">
                    <b><code class="methodname">fatalProtocolException</code>:&nbsp;</b>
                    
                    Triggered when an HTTP protocol error caused the connection to be terminated.
                    
                    </p>
                </li><li class="listitem">
                    <p title="connectionOpen:">
                    <b><code class="methodname">connectionOpen</code>:&nbsp;</b>
                    
                    Triggered when a new connection has been established.
                    
                    </p>
                </li><li class="listitem">
                    <p title="connectionClosed:">
                    <b><code class="methodname">connectionClosed</code>:&nbsp;</b>
                    
                    Triggered when the connection has been terminated.
                    
                    </p>
                </li><li class="listitem">
                    <p title="connectionTimeout:">
                    <b><code class="methodname">connectionTimeout</code>:&nbsp;</b>
                    
                    Triggered when the connection has timed out.
                    
                    </p>
                </li></ul></div>
        </div>
    </div>
    <div class="section" title="2.9.&nbsp;Non-blocking TLS/SSL"><div class="titlepage"><div><div><h2 class="title" style="clear: both"><a name="d4e1111"></a>2.9.&nbsp;Non-blocking TLS/SSL</h2></div></div></div>
        
        <div class="section" title="2.9.1.&nbsp;SSL I/O session"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1113"></a>2.9.1.&nbsp;SSL I/O session</h3></div></div></div>
            
            <p>
            <code class="classname">SSLIOSession</code> is a decorator class intended to transparently 
            extend any arbitrary <code class="interfacename">IOSession</code> with transport layer 
            security capabilities based on the SSL/TLS protocol. Individual protocol handlers 
            should be able to work with SSL sessions without special preconditions or 
            modifications. However, I/O dispatchers need to take some additional actions to ensure 
            correct functioning of the transport layer encryption.
            </p>
            <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                    <p>
                    When the underlying I/O session has been  created, the I/O dispatch must call 
                    <code class="methodname">SSLIOSession#bind()</code> method in order to put the SSL 
                    session either into a client or a server mode.
                    </p>
                </li><li class="listitem">
                    <p>
                    When the underlying I/O session is input ready, the I/O dispatcher should check 
                    whether the SSL I/O session is ready to produce input data by calling 
                    <code class="methodname">SSLIOSession#isAppInputReady()</code>, pass control to the 
                    protocol handler if it is, and finally call <code class="methodname">
                    SSLIOSession#inboundTransport()</code> method in order to do the 
                    necessary SSL handshaking and decrypt input data.
                    </p>
                </li><li class="listitem">
                    <p>
                    When the underlying I/O session is output ready, the I/O dispatcher should 
                    check whether the SSL I/O session is ready to accept output data by calling 
                    <code class="methodname">SSLIOSession#isAppOutputReady()</code>, pass control to the 
                    protocol handler if it is, and finally call <code class="methodname">
                    SSLIOSession#outboundTransport()</code> method in order to do the nessary 
                    SSL handshaking and encrypt application data.
                    </p>
                </li></ul></div>
            <div class="section" title="2.9.1.1.&nbsp;SSL I/O session handler"><div class="titlepage"><div><div><h4 class="title"><a name="d4e1130"></a>2.9.1.1.&nbsp;SSL I/O session handler</h4></div></div></div>
                
                <p>
                Applications can customize various aspects of the TLS/SSl protocol by passing a 
                custom implementation of the <code class="interfacename">SSLIOSessionHandler</code> 
                interface.
                </p>
                <p>
                SSL events as defined by the <code class="interfacename">SSLIOSessionHandler</code> 
                interface:
                </p>
                <div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
                        <p title="initalize:">
                        <b><code class="methodname">initalize</code>:&nbsp;</b>
                        
                        Triggered when the SSL connection is being initialized. The handler can use 
                        this callback to customize properties of the <code class="classname">
                        javax.net.ssl.SSLEngine</code> used to establish the SSL session.
                        
                        </p>
                    </li><li class="listitem">
                        <p title="verify:">
                        <b><code class="methodname">verify</code>:&nbsp;</b>
                        
                        Triggered when the SSL connection has been established and initial SSL 
                        handshake has been successfully completed. The handler can use this 
                        callback to verify properties of the !SSLSession. For instance this would 
                        be the right place to enforce SSL cipher strength, validate certificate 
                        chain and do hostname checks.
                        
                        </p>
                    </li></ul></div>
                <pre class="programlisting">
// Get hold of new I/O session
IOSession iosession; 

// Initialize default SSL context
SSLContext sslcontext = SSLContext.getInstance("SSL");
sslcontext.init(null, null, null);

SSLIOSession sslsession = new SSLIOSession(
    iosession, sslcontext, new SSLIOSessionHandler() {

    public void initalize(
        SSLEngine sslengine, 
        HttpParams params) throws SSLException {
        // Ask clients to authenticate
        sslengine.setWantClientAuth(true);
        // Enforce strong ciphers 
        sslengine.setEnabledCipherSuites(new String[] {
                "TLS_RSA_WITH_AES_256_CBC_SHA",
                "TLS_DHE_RSA_WITH_AES_256_CBC_SHA",
                "TLS_DHE_DSS_WITH_AES_256_CBC_SHA" });
    }

    public void verify(
        SocketAddress remoteAddress, 
        SSLSession session) throws SSLException {
        X509Certificate[] certs = session.getPeerCertificateChain();
        // Examine peer certificate chain
        for (X509Certificate cert: certs) {
            System.out.println(cert.toString());
        }
    }
    
}); 
</pre>
            </div>
        </div>
        <div class="section" title="2.9.2.&nbsp;SSL I/O event dispatches"><div class="titlepage"><div><div><h3 class="title"><a name="d4e1149"></a>2.9.2.&nbsp;SSL I/O event dispatches</h3></div></div></div>
            
            <p>
            HttpCore provides <code class="classname">SSLClientIOEventDispatch</code> and <code class="classname">
            SSLServerIOEventDispatch</code> I/O dispatch implementations that can be used to 
            SSL enable connections managed by any arbitrary I/O reactor. The dispatches take all 
            the necessary actions to wrap active I/O sessions with the SSL I/O session decorator 
            and ensure correct handling of the SSL protocol handshaking.
            </p>
        </div>
    </div>
</div><div class="navfooter"><hr><table width="100%" summary="Navigation footer"><tr><td width="40%" align="left"><a accesskey="p" href="fundamentals.html">Prev</a>&nbsp;</td><td width="20%" align="center">&nbsp;</td><td width="40%" align="right">&nbsp;<a accesskey="n" href="advanced.html">Next</a></td></tr><tr><td width="40%" align="left" valign="top">Chapter&nbsp;1.&nbsp;Fundamentals&nbsp;</td><td width="20%" align="center"><a accesskey="h" href="index.html">Home</a></td><td width="40%" align="right" valign="top">&nbsp;Chapter&nbsp;3.&nbsp;Advanced topics</td></tr></table></div></body></html>