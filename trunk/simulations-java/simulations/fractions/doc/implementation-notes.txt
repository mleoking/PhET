The Fractions sim uses functional programming in many parts.
Models for all tabs are immutable classes with public final immutable attributes, and Lombok-generate equality tests, constructors, etc.

To support the functional paradigm, this sim used FunctionalJava, http://functionaljava.org/ and Lombok http://projectlombok.org/
For a nice book on functional programming in Java, please see http://www.amazon.com/Functional-Programming-Java-Developers-Concurrency/dp/1449311032

In order to maintain a reasonable matching with piccolo, many model elements are converted into Property<T> instances which are used to sync with the model.
Where performance allows, large piccolo subtrees are reconstructed (not mutated) whenever the corresponding part of the model changes.

The immutable model objects are updated using copy methods.  The convention that I used for this sim is to give the copy method a name like "withValue",
and to only provide one argument to each copy method.  Convention for copy methods is to use method of the name of the variable and to call the constructor with the
arguments of the same names as the parameters to make it easy to see that everything is correct.
These should be written right after the constructors (or field declarations) if no constructors, and use single-line method
"simple methods in one line" in IntelliJ code style.  For example,
if the main constructor was State(name,x,y), then the copy method for x would be:

public State withX(double x){ return new State(name,x,y);}

To change multiple values, multiple copy calls would be made, such as:
State newState = state.withName("new name").withX(123);

The Intro module uses a novel technique for supporting multiple representations with Property<T> while avoiding looping, please see this ticket for details:
https://phet.unfuddle.com/a#/projects/9404/tickets/by_number/3259
The Intro model has one representation for each view type, and another one called "ContainerSet" to represent a more abstract view of which cells are filled and unfilled.

To summarize, the class ClientProperty provides a way to view when a certain value in the model changes, and describes what to do when
the value is changed from outside of the model.

Package structure:
The package structure was designed to be similiar to a structure in which sim had its own project.  That means:
edu/colorado/phet/fractions: Common code, name of the project (may also have a sim later if we name a sim "fractions").
I will consider renaming this fractions-common, but that would require updating the resource generator
edu/colorado/phet/fractionsintro: "Fractions Intro" sim

Closures:
This sim was designed with many closures, and is intended to be read in an IDE with "closure-folding" feature enabled.
Also, closure variables are abbreviated to improve readability, for example, using:
F(SliceNodeArgs s) {return new ShapeNode(s.slice);}
instead of the more verbose:
F(SliceNodeArgs sliceNodeArgs) {return new ShapeNode(sliceNodeArgs.slice);}

This sim uses single-line methods elsewhere ("simple methods in one line" in IntelliJ) to improve readability for short methods.

The animation is implemented in the model instead of piccolo because it is (a) conceptually natural (that the location of objects is in the model and not just how they look),
(b) so that if we port it to another platform (such as Android), the model will still work properly and (c) it led to easy and uniform code

Matching Game:
The model is immutable, while the view is mutable. This had to be done for performance reasons,
and is accomplished by introducing "ids" into the model and mapping them back to view objects.

Build a Fraction:
ID's are used to identify objects over time, they were introduced to facilitate integration with piccolo.  One separate ClassID class is created for each model type that needs ID.
Not sure if there is a way around this or a better way to do this.  This is a significant drawback, and a good argument in favor of doing imperative instead of functional programming.
On the other hand, tracking objects around the screen has been a requested feature of sim sharing, and this would make it trivial.
Referencing objects by ID's also has the following tradeoff: lots of .some() calls sprinkled in the model code (or checks for isSome()).
In reference/identity equality, we typically don't check
to see that the instance is still contained in the model and hence sometimes erroneously act on model items that have been removed already.

Update: While functional programming worked well for the other tabs in Fractions Introduction, it is proving more problematic for the "build a fraction" tab for the following reasons:
    1. Graph-like structures (instead of tree-like) have led to creating a family of EntityID classes, which seems like a bad tradeoff
    2. Creating/moving/changing lots of different data types is leading to tricky handling with piccolo code, in particular, when an object looks similar but behaves differently,
       should a different PNode be created?
    3. It wasn't clear how to efficiently convert model changes into view observer events--my current implementation observes for state changes and checks to see what
       changed--a more efficient and straightforward implementation may be to just fire those on the change methods themselves.
    4. Piccolo already provides great animation features that would have to be duplicated in a functional re-implementation.

    So I am going to try a more imperative approach for this model and see if it goes more smoothly.  I think functional programming should be reconsidered
    (a) for treelike models
    (b) if/when we get a scene graph that works better with a functional model
    (c) if/when we need more powerful simsharing or sim-event-data-collection
    (d) if/when we want to be able to record a test suite of function invocations for regression testing
    (e) if/when we start using languages or libraries that are more supportive of functional programming (e.g. scala or lombok-pg)