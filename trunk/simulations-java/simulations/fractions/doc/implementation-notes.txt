The Fractions sim uses functional programming in many parts.
Models for all tabs are immutable classes with public final immutable attributes, and Lombok-generate equality tests, constructors, etc.

To support the functional paradigm, this sim used FunctionalJava, http://functionaljava.org/ and Lombok http://projectlombok.org/
For a nice book on functional programming in Java, please see http://www.amazon.com/Functional-Programming-Java-Developers-Concurrency/dp/1449311032

For historical reasons, the different tabs have different ways of representing the views.
The Intro tab and Equality Lab tab map the immutable model into Property<T> instances which are used to sync with the model.
For the matching game (and for the shape graphics in the other 2 tabs), the entire scene graph is reconstructed and redrawn whenever the model changes.
This does not seem to have a significantly negative impact on the performance.  For future work, I would recommend the "matching game" strategy, if it is feasible
for scenes that are more expensive to paint.

The immutable model objects are updated using copy methods.  The convention that I used for this sim is to give the copy method the name of the variable being set,
and to only provide one argument to each copy method.  Convention for copy methods is to use method of the name of the variable and to call the constructor with the
arguments of the same names as the parameters to make it easy to see that everything is correct.
These should be written right after the constructors (or field declarations) if no constructors, and use single-line method
"simple methods in one line" in IntelliJ code style.  For example,
if the main constructor was State(name,x,y), then the copy method for x would be:

public State x(double x){ return new State(name,x,y);}

To change multiple values, multiple copy calls would be made, such as:
State newState = state.name("new name").x(123);

The Intro module uses a novel technique for supporting multiple representations with Property<T> while avoiding looping, please see this ticket for details:
https://phet.unfuddle.com/a#/projects/9404/tickets/by_number/3259
The Intro model has one representation for each view type, and another one called "ContainerSet" to represent a more abstract view of which cells are filled and unfilled.

To summarize, the class ClientProperty provides a way to view when a certain value in the model changes, and describes what to do when
the value is changed from outside of the model.

Package structure:
The package structure was designed to be similiar to a structure in which sim had its own project.  That means:
edu/colorado/phet/fractions: Common code, name of the project (may also have a sim later if we name a sim "fractions").  I will consider renaming this fractions-common, but that would require updating the resource generator
edu/colorado/phet/fractionsintro: "Fractions Intro" sim

Closures:
This sim was designed with many closures, and is intended to be read in an IDE with "closure-folding" feature enabled.
Also, closure variables are abbreviated to improve readability, for example, using:
F(SliceNodeArgs s) {return new ShapeNode(s.slice);}
instead of the more verbose:
F(SliceNodeArgs sliceNodeArgs) {return new ShapeNode(sliceNodeArgs.slice);}

This sim uses single-line methods elsewhere ("simple methods in one line" in IntelliJ) to improve readability for short methods

The animation is implemented in the model instead of piccolo because it is (a) conceptually natural (that the location of objects is in the model and not just how they look),
(b) so that if we port it to another platform (such as Android), the model will still work properly and (c) it led to easy and uniform code

Build a Fraction:
ID's are used to identify objects over time, they were introduced to facilitate integration with piccolo.  One separate ClassID class is created for each model type that needs ID.
Not sure if there is a way around this or a better way to do this.  This is a significant drawback, and a good argument in favor of doing imperative instead of functional programming.
On the other hand, tracking objects around the screen has been a requested feature of sim sharing, and this would make it trivial.
Referencing objects by ID's also has the following tradeoff: lots of .some() calls sprinkled in the model code (or checks for isSome()).  In reference/identity equality, we typically don't check
to see that the instance is still contained in the model and hence sometimes erroneously act on model items that have been removed already.