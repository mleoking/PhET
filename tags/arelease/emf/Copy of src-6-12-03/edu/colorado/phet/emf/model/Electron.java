/**
 * Class: Electron
 * Package: edu.colorado.phet.waves.model
 * Author: Another Guy
 * Date: May 23, 2003
 */
package edu.colorado.phet.emf.model;

import edu.colorado.phet.command.AddFieldElementCmd;
import edu.colorado.phet.common.math.Vector2D;
import edu.colorado.phet.common.model.ModelElement;
import edu.colorado.phet.emf.EmfApplication;
import edu.colorado.phet.emf.model.FieldElement;
import edu.colorado.phet.emf.model.movement.MovementType;
import edu.colorado.phet.emf.model.movement.ManualMovement;
import edu.colorado.phet.emf.model.movement.SinusoidalMovement;

import java.awt.*;
import java.awt.geom.Point2D;

public class Electron extends ModelElement {

    private Point2D startPosition;
    private Point2D prevPosition = new Point2D.Double();
    private Point2D currentPosition = new Point2D.Double();
    private Vector2D velocity = new Vector2D();
    private MovementType movementStrategy;
    private double runningTime;

    // Number of time steps between emitting field elements. This
    // provides and animated look to the visualization.
    // TODO: this mechanism should be implemented in the view, not here
    private int steps = 0;
    // An array to hold the history of field strengths generated by
    // the electron as it moves over time
    private Vector2D[] retardedField = new Vector2D[s_retardedFieldLength];
    // The position history of the electron
    private Point2D[] positionHistory = new Point2D.Float[s_retardedFieldLength];
    private Vector2D[] accelerationHistory = new Vector2D[s_retardedFieldLength];
    private boolean changeFreq;
    private float newFreq;


    public Electron( Point2D.Double startPosition ) {
        this.startPosition = new Point2D.Double( startPosition.getX(), startPosition.getY() );
        this.currentPosition = new Point2D.Double( startPosition.getX(), startPosition.getY() );
        for( int i = 0; i < s_retardedFieldLength; i++ ) {
            retardedField[i] = new Vector2D( 0, 0 );
            positionHistory[i] = new Point2D.Float( Float.NaN, Float.NaN );
            accelerationHistory[i] = new Vector2D();
        }
    }

    public Point2D getCurrentPosition() {
        return currentPosition;
    }

    public void setCurrentPosition( Point2D newPosition ) {
        currentPosition.setLocation( newPosition );
    }

    public void setMovementStrategy( MovementType movementStrategy ) {
        this.movementStrategy = movementStrategy;
    }

    public synchronized void stepInTime( double dt ) {
        prevPosition.setLocation( currentPosition );
        movementStrategy.stepInTime( this, dt );
        runningTime += dt;

//        setCurrentPosition( movementStrategy.getNextPosition( startPosition, runningTime ) );
//
//        double vx = ( currentPosition.getX() - prevPosition.getX() ) / dt;
//        double vy = ( currentPosition.getY() - prevPosition.getY() ) / dt;
//        velocity.setX( (float)vx );
//        velocity.setY( (float)vy );
        propagateRetardedField( new Vector2D( 0, movementStrategy.getAcceleration( this ) ));
        recordPosition( currentPosition );

        // If we have a frequency change pending, determine if this is the right time to
        // make it
        if( changeFreq && movementStrategy instanceof SinusoidalMovement ) {
            if( ( prevPosition.getY() - startPosition.getY() ) * ( currentPosition.getY() - startPosition.getY() ) <= 0 ) {
                SinusoidalMovement sm = (SinusoidalMovement)movementStrategy;
                sm.setFrequency( newFreq );
                changeFreq = false;
            }
        }

        updateObservers();
    }

    /**
     *
     */
    public synchronized void moveToNewPosition( Point newLocation ) {
        if( movementStrategy instanceof ManualMovement ) {
            ( (ManualMovement)movementStrategy ).setPosition( newLocation );
        }
    }

    /**
     * Progagates field strength through the retarded field
     * @param fieldStrength
     */
    private void propagateRetardedField( Vector2D fieldStrength ) {
        for( int i = s_retardedFieldLength - 1; i > s_stepSize - 1; i-- ) {
            retardedField[i].setX( retardedField[i - 1].getX() );
            retardedField[i].setY( retardedField[i - 1].getY() );
        }
        retardedField[0].setX( fieldStrength.getX() );
        retardedField[0].setY( fieldStrength.getY() );
    }

    private void recordPosition( Point2D position ) {
        for( int i = s_retardedFieldLength - 1; i > s_stepSize - 1; i-- ) {
            positionHistory[i].setLocation( positionHistory[i - s_stepSize] );
            accelerationHistory[i].setX( accelerationHistory[i - s_stepSize].getX() );
            accelerationHistory[i].setY( accelerationHistory[i - s_stepSize].getY() );
        }

        for( int i = 0; i < s_stepSize; i++ ) {
            positionHistory[i].setLocation( position );
            accelerationHistory[i].setY( movementStrategy.getAcceleration( this ));
            System.out.println(  movementStrategy.getAcceleration( this ) );
//            accelerationHistory[i].setY( getAccelerationAt( 0 ) );
        }
    }

    private void emitFieldElements() {
        double c = 5;
        steps = ( steps + 1 ) % 3;
        if( steps == 0 ) {
            for( double theta = 0; theta < Math.PI * 2; theta += Math.PI * 2 / 8 ) {
                double vx = c * Math.cos( theta );
                double vy = c * Math.sin( theta );
                FieldElement fieldElement = new FieldElement( this.currentPosition,
                                                              new Vector2D( (float)vx, (float)vy ) );
                new AddFieldElementCmd( fieldElement ).doIt();
            }
        }
    }

    public Vector2D getVelocity() {
        return this.velocity;
    }

    public Vector2D getFieldAtTimeAgo( double sourceTime ) {
        int historyIndex = (int)( EmfApplication.s_speedOfLight * sourceTime );
        return retardedField[historyIndex];
    }

    public Point2D getStartPosition() {
        return this.startPosition;
    }

    private Vector2D staticFieldStrength = new Vector2D();
    public Vector2D getInstantaneousStaticField( Point2D location ) {
        staticFieldStrength.setX( (float)( location.getX() - getCurrentPosition().getX() ) );
        staticFieldStrength.setY( (float)( location.getY() - getCurrentPosition().getY() ) );
        staticFieldStrength.normalize();

        double distanceFromSource = location.distance( this.getCurrentPosition() );
        staticFieldStrength.multiply( s_B / (float)( distanceFromSource * distanceFromSource ) );
        return staticFieldStrength;
    }

    private Vector2D dynamicFieldStrength = new Vector2D();
    private Vector2D getInstantaneousDynamicField( Point2D location ) {
        dynamicFieldStrength.setX( 0 );
        dynamicFieldStrength.setY( 1 );

//        float acceleration = accelerationHistory[(int)location.getX() ].getY();
        float acceleration = this.getAccelerationAt( (int)location.getX() );
        double distanceFromSource = location.distance( this.getCurrentPosition() );
        dynamicFieldStrength.multiply( acceleration * 0.02f * s_B / (float)( distanceFromSource ) );

        if( dynamicFieldStrength.getLength() > 50 ) {
            System.out.println( "" );
        }

        return dynamicFieldStrength;
    }

    private Vector2D fieldStrength = new Vector2D();
    public Vector2D getFieldAtLocation( Point2D location ) {
        fieldStrength.setX( 0 );
        fieldStrength.setY( 0 );
        if( EmfModel.instance().isStaticFieldEnabled() ) {
            fieldStrength.add( getInstantaneousStaticField( location ) );
        }
        if( EmfModel.instance().isDynamicFieldEnabled() ) {
            fieldStrength.add( getInstantaneousDynamicField( location ) );
        }

        return fieldStrength;
    }

    private float getAccelerationAt( int x ) {
        return accelerationHistory[x].getY();

/* Commented out on Friday to use acceleration from MovementType
//        int stepSize = 10;
//        int stepSize = (int)EmfApplication.s_speedOfLight;
        float dt = (float)EmfModel.instance().getClock().getDt();
        float vy1 = (float)( positionHistory[x + 1 * s_stepSize].getY() - positionHistory[x + 2 * s_stepSize].getY() ) / dt;
        float vy2 = (float)( positionHistory[x].getY() - positionHistory[x + 1 * s_stepSize].getY() ) / dt;

        float acceleration = ( vy2 - vy1 ) / dt;
        if( positionHistory[x].getX() == positionHistory[x + s_stepSize].getX()
                && positionHistory[x].getY() == positionHistory[x + s_stepSize].getY()
                || positionHistory[x + s_stepSize].getX() == positionHistory[x + 2 * s_stepSize].getX()
                && positionHistory[x + s_stepSize].getY() == positionHistory[x + 2 * s_stepSize].getY() ) {
            acceleration = 0;
        }
        if( Double.isNaN( positionHistory[x + 2 * s_stepSize].getX() ) || Double.isNaN( positionHistory[x + 2 * s_stepSize].getY() ) ) {
            acceleration = 0;
        }
        return acceleration;
*/
    }

    public float getMass() {
        //mr = m0 /sqrt(1 - v2/c2)
        float vMag = this.getVelocity().getLength();
        float denom = 1f - (float)Math.sqrt( ( vMag * vMag ) / ( EmfApplication.s_speedOfLight * EmfApplication.s_speedOfLight ) );
        float mr = s_restMass / denom;
        return mr;
    }

    public void setFrequency( float freq ) {
        if( this.movementStrategy instanceof SinusoidalMovement ) {
            changeFreq = true;
            newFreq = freq;
        }
    }

    //
    // Static fields and methods
    //
    private static final int s_retardedFieldLength = 1000;
//    private static final int s_retardedFieldLength = 600;
    private static final float s_B = 100000;
    private static final float s_restMass = 1;
    private static int s_stepSize = (int)( EmfApplication.s_speedOfLight / 4 );

}
