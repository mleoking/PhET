import java.awt.*;
import java.awt.event.*;
import java.util.Vector;


/**
 * Implements additional helper methods for managing a control panel
 * along the bottom edge of the applet.  Applets not wishing to use such a
 * panel should extend	{@link BaseApplet BaseApplet} instead.
 * <p/>
 * Any buttons, textfields, or checkboxes added to the panel will be
 * automatically registered to trigger <code>ActionEvent</code>s on
 * interaction with the user.
 * <p/>
 * The {@link #add(Component) add()} and
 * {@link #setLayout(LayoutManager) setLayout} methods refer to this panel
 * instead of the whole applet.
 */
public abstract class BaseApplet2 extends BaseApplet implements TextListener, FocusListener {
    /**
     * Performs extra initialisation, including adding a panel to the
     * bottom of the applet.
     */
    public void init() {
        super.init();

        super.setLayout( new BorderLayout() );
        panel = new Panel();
        super.add( panel, BorderLayout.SOUTH );

        buttons = new Vector();
        fields = new Vector();
        boxes = new Vector();

        statusLabel = new Label();
        statusLabel.setForeground( Color.red );

        Color orig = getBackground();
        setBackground( Color.white );
        panel.setBackground( orig );
    }


    /**
     * Sets the layout manager to use for the control panel.
     *
     * @param    lm    The layout manager
     */
    public void setLayout( LayoutManager lm ) {
        if( panel == null ) {
            super.setLayout( lm );
        }
        else {
            panel.setLayout( lm );
        }
    }


    /**
     * Returns an instance of <code>Container</code>, of a subclass chosen
     * at the discretion of the applet.
     */
    protected Container makePanel() {
        if( useSwing ) {
            try {
                Class c = Class.forName( "javax.swing.JPanel" );
                java.lang.reflect.Constructor con = c.getConstructor( new Class[]{} );
                return (Container)con.newInstance( new Object[]{} );
            }
            catch( Throwable t ) {
                useSwing = false;
            }
        }

        return new Panel();
    }


    /**
     * Returns an instance of <code>Button</code>, of a subclass chosen
     * at the discretion of the applet.
     *
     * @param    label    The text which will appear on the button
     */
    protected Component makeButton( String label ) {
        if( useSwing ) {
            try {
                Class c = Class.forName( "javax.swing.JButton" );
                java.lang.reflect.Constructor con = c.getConstructor( new Class[]{"".getClass()} );
                return (Component)con.newInstance( new Object[]{label} );
            }
            catch( Throwable t ) {
                useSwing = false;
            }
        }
        return new FixedButton( label );
    }


    /**
     * Creates a button, and adds it to the control panel.
     *
     * @param    label    The text to display on the button
     * @return The button created
     */
    public Button addButton( String label ) {
        return (Button)add( makeButton( label ) );
    }


    /**
     * Creates a text field, and adds it to the control panel.
     *
     * @param    label    The initial text for the field
     * @return The field created
     */
    public TextField addField( String label, String value ) {
        return (TextField)add( new TextField( value ), label );
    }


    /**
     * Creates a text field, and adds it to the control panel.
     *
     * @param    value    The initial value for the field
     * @return The field created
     */
    public TextField addField( String label, double value ) {
        return addField( label, "" + value );
    }


    /**
     * Creates a text field, and adds it to the control panel.
     *
     * @param    value    The initial value for the field
     * @return The field created
     */
    public TextField addField( String label, int value ) {
        return addField( label, "" + value );
    }


    /**
     * Creates a checkbox, and adds it to the control panel.
     *
     * @param    value    The initial value for the field
     * @return The field created
     */
    public Checkbox addCheckbox( String label, boolean value ) {
        return (Checkbox)add( new FixedCheckbox( label, value ) );
    }


    /**
     * Registers a component with the applet.  Any <code>ItemEvent</code>
     * or <code>ActionEvent</code> generated by the component will now be
     * passed on to the
     * {@link #actionPerformed(ActionEvent) actionPerformed()} method
     * implemented by the subclass.
     *
     * @param    c    The component to register
     */
    protected void register( Component c ) {
        if( c instanceof Button ) {
            buttons.addElement( c );
        }
        if( c instanceof TextField ) {
            fields.addElement( c );
            ( (TextField)c ).addTextListener( this );
            c.addFocusListener( this );
        }
        if( c instanceof Checkbox ) {
            boxes.addElement( c );
        }
    }


    /**
     * Adds a component to the control panel, and {@link #register(Component)
     * register()}s the component.
     *
     * @param    c    The component to add
     */
    public Component add( Component c ) {
        register( c );
        return panel.add( c );
    }


    /**
     * Adds a text label to the control panel, followed by the specified
     * component, and {@link #register(Component) register()}s the component.
     *
     * @param    c        The component to add
     * @param    text The label for the component
     */
    public Component add( Component c, String text ) {
        panel.add( new Label( text ) );
        return add( c );
    }

    public void start() {
        super.start();
        addListeners();
        setPromptEnabled( true );
    }

    public void stop() {
        setPromptEnabled( false );
        removeListeners();
        super.stop();
    }


    /**
     * Used internally to add listeners for all registered components
     */
    protected void addListeners() {
        for( int i = 0; i < buttons.size(); i++ ) {
            ( (Button)buttons.elementAt( i ) ).addActionListener( this );
        }
        for( int i = 0; i < fields.size(); i++ ) {
            ( (TextField)fields.elementAt( i ) ).addActionListener( this );
        }
        for( int i = 0; i < boxes.size(); i++ ) {
            ( (Checkbox)boxes.elementAt( i ) ).addItemListener( this );
        }
    }


    /**
     * Used internally to add listeners for all registered components
     */
    protected void removeListeners() {
        for( int i = 0; i < buttons.size(); i++ ) {
            ( (Button)buttons.elementAt( i ) ).removeActionListener( this );
        }
        for( int i = 0; i < fields.size(); i++ ) {
            ( (TextField)fields.elementAt( i ) ).removeActionListener( this );
        }
        for( int i = 0; i < boxes.size(); i++ ) {
            ( (Checkbox)boxes.elementAt( i ) ).removeItemListener( this );
        }
    }


    /**
     * Returns the available space for graphs (or whatever the remainder
     * of the display is to be used for).
     */
    public int getGraphHeight() {
        return getSize().height - panel.getSize().height - V_MARGIN;
    }


    /**
     * Parses a <code>TextField</code> into an <code>int</code>.
     *
     * @param    tf    The field to parse
     * @return The parsed value
     * @throws NumberFormatException    If the parsing fails
     */
    public int getInt( TextField tf ) {
        return Integer.parseInt( tf.getText() );
    }


    /**
     * Parses a <code>TextField</code> into a <code>double</code>.
     *
     * @param    tf    The field to parse
     * @return The parsed value
     * @throws NumberFormatException    If the parsing fails
     * @throws IllegalArgumentException    If the absolute value is less
     * than 10e-8 (a measure to prevent unexpected underflow)
     */
    public double getDouble( TextField tf ) {
        double d = Double.valueOf( tf.getText() ).doubleValue();
        if( d != 0 && Math.abs( d ) < 0.00000001 ) {
            throw new IllegalArgumentException( "need abs value >= 10e-8" );
        }
        return d;
    }


    /**
     * Disables all registed components
     */
    protected void lockControls() {
        setComponentsEnabled( buttons, false );
        setComponentsEnabled( boxes, false );
        setComponentsEnabled( fields, false );
    }


    /**
     * Enables all registed components
     */
    protected void unlockControls() {
        setComponentsEnabled( buttons, true );
        setComponentsEnabled( boxes, true );
        setComponentsEnabled( fields, true );
    }


    /**
     * Used internally to enable or disable a <code>Vector</code> of
     * components.
     *
     * @param    v    The vector of components
     * @param    b    <code>true</code> if the components are to be enabled,
     * else <code>false</code>
     */
    private static void setComponentsEnabled( Vector v, boolean b ) {
        for( int i = 0; i < v.size(); i++ ) {
            ( (Component)v.elementAt( i ) ).setEnabled( b );
        }
    }


    /**
     * Called when the contents of a text field have changed.  If the user
     * appears to have modified the value, the {@link #statusLabel
     * statusLabel} will prompt the user to press <code>return</code>.
     */
    public void textValueChanged( TextEvent te ) {
        //System.err.println("got text event");
        //repaint();
        if( enablePrompt && ( te.getSource() == focus ) ) {
            statusLabel.setText( "Hit return to apply" );
        }
    }


    /**
     * Used to track focus to discern user-triggered changes from automatic
     * changes.
     */
    public void focusGained( FocusEvent fe ) {
        focus = fe.getSource();
    }


    /**
     * Used to track focus to discern user-triggered changes from automatic
     * changes.
     */
    public void focusLost( FocusEvent fe ) {
        if( fe.getSource() == focus ) {
            focus = null;
        }
    }


    /**
     * Used to enable or disable user input prompting.
     */
    public void setPromptEnabled( boolean b ) {
        enablePrompt = b;
    }


    /**
     * Helper method to display horizontal dashed lines
     *
     * @param dashLen The size of dash to use
     * @param    g    The Graphics surface on which to paint
     * @param    x    The x-coordinate of the start of the line
     * @param    y    The y-coordinate of the start of the line
     * @param    x2    The x-coordinate of the end of the line
     */
    protected void paintDashedLineH( Graphics g, int x, int y, int x2, int dashLen ) {
        for( ; x < x2; x += 2 * dashLen ) {
            g.drawLine( x, y, Math.min( x + dashLen, x2 ), y );
        }
    }

    /**
     * Helper method to display vertical dashed lines
     *
     * @param dashLen The size of dash to use
     * @param    g    The Graphics surface on which to paint
     * @param    x    The x-coordinate of the start of the line
     * @param    y    The y-coordinate of the start of the line
     * @param    y2    The y-coordinate of the end of the line
     */
    protected void paintDashedLineV( Graphics g, int x, int y, int y2, int dashLen ) {
        for( ; y < y2; y += 2 * dashLen ) {
            g.drawLine( x, y, x, Math.min( y + dashLen, y2 ) );
        }
    }

    public static String toString( double d ) {
        String s = "" + d;
        int i = Math.max( s.indexOf( 'e' ), s.indexOf( 'E' ) );
        if( i < 0 ) {
            i = s.length();
        }
        String exp = s.substring( i );
        String mantissa = s.substring( 0, i );
        i = Math.max( s.indexOf( '.' ), 6 );
        i = Math.min( mantissa.length(), i );
        return mantissa.substring( 0, i ) + exp;
    }


    protected Object focus;
    protected Vector buttons, fields, boxes;
    protected Panel panel;
    protected Label statusLabel;
    protected boolean useSwing = false, enablePrompt = false;
    public static final int V_MARGIN = 5;


    /**
     * Mozilla-friendly Button
     */
    class FixedButton extends Button {
        public FixedButton( String label ) {
            super( label );
            addMouseListener( new MouseAdapter() {
                public void mousePressed( MouseEvent me ) {
                    _processActionEvent();
                }
            } );
        }

        protected void _processActionEvent() {
            super.processActionEvent( new ActionEvent( this, ActionEvent.ACTION_PERFORMED, getActionCommand() ) );
        }

        public void processActionEvent( ActionEvent ae ) {
            //super.processActionEvent(ae);
            //System.err.println("ActionEvent received:  "+ae);
        }
    }


    /**
     * Mozilla-friendly Checkbox
     */
    class FixedCheckbox extends Checkbox {
        public FixedCheckbox( String label, CheckboxGroup cbg, boolean on ) {
            super( label, cbg, on );
            addMouseListener( new MouseAdapter() {
                public void mousePressed( MouseEvent me ) {
                    doClick();
                }
            } );
        }

        public FixedCheckbox( String label, boolean on ) {
            this( label, null, on );
        }

        protected void doClick() {
            //System.err.println("got click");
            state = !state;
            //setState(state);
            //setState(!getState());
            //setState(!getState());
            int type = state ? ItemEvent.SELECTED : ItemEvent.DESELECTED;
            ItemEvent ie = new ItemEvent( this, ItemEvent.ITEM_STATE_CHANGED, this, type );
            notifyListeners( ie );
            //super.processEvent(ie);
        }

        protected void processItemEvent( ItemEvent ie ) {
            //System.err.println("Ignoring ItemEvent");
        }

        /*protected void processEvent(AWTEvent e)
          {
              //System.err.println("Ignoring AWTEvent:  "+e);
          } */

        public void addItemListener( ItemListener e ) {
            listeners.addElement( e );
        }

        public void removeItemListener( ItemListener e ) {
            listeners.removeElement( e );
        }

        protected void notifyListeners( ItemEvent e ) {
            //System.err.println("Sending event");
            for( int i = 0; i < listeners.size(); i++ ) {
                ( (ItemListener)listeners.elementAt( i ) ).itemStateChanged( e );
            }
        }

        public boolean getState() {
            return state;
        }


        protected boolean state = getState();
        protected java.util.Vector listeners = new java.util.Vector();
    }


    public abstract class GraphClickListener extends MouseAdapter implements MouseMotionListener {
        public GraphClickListener( Plotter2 p ) {
            this.p = p;
        }

        public GraphClickListener() {
            this( null );
        }

        public void setPlotter( Plotter2 p ) {
            this.p = p;
        }

        public boolean ignoreEvent( MouseEvent me ) {
            return
                    ( ( me.getModifiers() & me.BUTTON1_MASK ) == 0 )
                    // IRIX workaround
                    && ( ( me.getModifiers() & ( me.BUTTON2_MASK | me.BUTTON3_MASK ) ) != 0 );


        }

        public void mousePressed( MouseEvent me ) {
            if( ignoreEvent( me ) ) {
                return;
            }
            setPromptEnabled( false );
            requestFocus();
            statusLabel.setText( "" );
            _update( me.getX(), me.getY(), true, false );
        }

        public void mouseReleased( MouseEvent me ) {
            if( ignoreEvent( me ) ) {
                return;
            }
            _update( me.getX(), me.getY(), false, true );
            active = false;
            setPromptEnabled( true );
        }

        public void mouseMoved( MouseEvent me ) {
        }

        public void mouseDragged( MouseEvent me ) {
            if( ignoreEvent( me ) ) {
                return;
            }
            _update( me.getX(), me.getY(), false, false );
        }

        protected void _update( int x, int y, boolean mousePressed, boolean mouseReleased ) {
            y = p.h - y - p.vSpace;

            if( mousePressed && x < p.x + p.w && x >= p.x && y < p.y + p.h && y >= p.y ) {
                active = true;
            }

            if( !active ) {
                return;
            }

            double _x = p.fromScreenX( x );
            double _y = p.fromScreenY( y );

            _x = Math.max( p.viewLeft, Math.min( p.viewRight, _x ) );
            _y = Math.max( p.minY, Math.min( p.maxY, _y ) );

            update( _x, _y, mousePressed, mouseReleased );
        }

        public void update( double x, double y, boolean mousePressed, boolean mouseReleased ) {
            update( x, y );
        }

        public abstract void update( double x, double y);



		protected Plotter2 p;
		protected boolean active = false;
    }

}
